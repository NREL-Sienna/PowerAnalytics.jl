var documenterSearchIndex = {"docs":
[{"location":"tutorials/PA_workflow_tutorial/#Scenarios_PA_tutorial","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/#System","page":"Simulation Scenarios Analysis","title":"System","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"In this tutorial, we post-process the simulation results of the Reliability Test System Grid Modernization Lab Consortium (RTS-GMLC) system (DOI: 10.1109/TPWRS.2019.2925557), which is an updated version of the RTS-96 with an artificial location situated on an area that covers parts of California, Nevada and Arizona in the southwestern United States.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"The RTS-GMLC test system consists of:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"73 buses,\n105 transmission lines,\n157 generators (including 76 thermal generators, 57 solar PV facilities, 4 wind turbines, 20 hydro units),\n1 short-duration (3 hours) storage device with 100% charging and discharging efficiency","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"<p align=\"center\">\n  <img src=\"../../assets/nodemap_RTSGMLC.png\" width=\"700\">\n  <br>\n  <b>Fig. 1 - <a href=\"https://github.com/GridMod/RTS-GMLC/blob/master/node_re_basemap.png\">RTS-GMLC system</a></b>\n</p>","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Simulation-Scenarios","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We have obtained simulation results for the following two simulation scenarios:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Scenario 1: simulation using the RTS-GMLC test system without any additional modifications (baseline scenario)\nScenario 2: simulation using the RTS-GMLC test system with increased energy and power capacity of the storage device","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"The simulations were performed using the PowerSystems.jl and PowerSimulations.jl packages of Sienna. The CopperPlatePowerModel formulation was considered for the NetworkModel, while the formulations chosen for each of the component types we want to include in the simulation are presented in the table below:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Component Type Formulation\nLine StaticBranch\nTapTransformer StaticBranch\nThermalStandard ThermalBasicUnitCommitment\nRenewableDispatch RenewableFullDispatch\nRenewableNonDispatch FixedOutput\nHydroDispatch HydroDispatchRunOfRiver\nHydroEnergyReservoir HydroDispatchRunOfRiver\nEnergyReservoirStorage StorageDispatchWithReserves\nPowerLoad StaticPowerLoad","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"info: Info\nMore information regarding the different formulations can be found in the PowerSimulations.jl Formulation Library.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We document the above here for completeness, since those will directly define the structure of the optimization problem and consequently its auxiliary variables, expressions, parameters and variables for which realized result values are available.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"The script that was used to configure and execute the simulation scenarios referenced above can be found here.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Loading-Simulation-Scenario-Results","page":"Simulation Scenarios Analysis","title":"Loading Simulation Scenario Results","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We begin by loading all the necessary Julia packages.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"using PowerSystems\nusing PowerSimulations\nusing StorageSystemsSimulations\nusing HydroPowerSimulations\nusing DataFrames\nusing Dates\nusing CSV\nusing Plots\nusing PowerAnalytics\nusing PowerAnalytics.Metrics","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"To begin our analysis, we first specify the directory where the simulation results are stored. In our case, the results of both simulation scenarios have been saved within the same directory.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"results_dir = \"_simulation_results_RTS\"","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Once we have defined the directory containing our simulation results, the next step is to load them into a structured format for our analysis.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"create_problem_results_dict facilitates this by constructing a dictionary where each key corresponds to a scenario name.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We also specify \"UC\", which corresponds to the name we assigned when creating the DecisionModel and refers to the results of the unit commitment simulation. The populate_system=true argument ensures that the system model is attached to the results.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"results_all = create_problem_results_dict(results_dir, \"UC\"; populate_system = true)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Single-Scenario-Results","page":"Simulation Scenarios Analysis","title":"Single Scenario Results","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"In this section of the tutorial, we focus on the results of a single simulation scenario. Since the results_all dictionary contains entries for multiple scenarios, we can extract the results for a particular one using its name:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"results_uc = results_all[\"Scenario_1\"]","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Notice that in the output, the names of the realized auxiliary variables, problem expressions, problem parameters, and problem variables available in the results are all listed.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Obtain-the-generation-time-series-for-each-individual-thermal-component-of-the-system","page":"Simulation Scenarios Analysis","title":"Obtain the generation time series for each individual thermal component of the system","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"After confirming that the key ActivePowerVariable__ThermalStandard is present among the realized variables, we can now extract the generation time series for all the thermal (ThermalStandard) generators in our system. To achieve this, we follow two steps:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Create a ComponentSelector that identifies the component type we are interested in (in this case ThermalStandard), similarly to how one would call get_components.\nthermal_standard_selector = make_selector(ThermalStandard)\nCalculate the active power for the corresponding generators of this type using one of PowerAnalytics.jl defined metrics, namely calc_active_power, which retrieves the generation time series from the results.\ndf = calc_active_power(thermal_standard_selector, results_uc);\nshow(df; allcols = true)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Notice that in the resulting dataframe, each column represents the time series of an individual component. This behavior follows from the default settings of make_selector, since we have not specified any additional arguments to modify the default grouping.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"It is also important to keep in mind that by default, only the available components of the system will be included in the resulting dataframe.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"info: Info\nFor a complete list of the PowerAnalytics.jl built-in metrics, please refer to: PowerAnalytics Built-In Metrics.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Obtain-the-thermal-generation-time-series-grouped-by-prime_mover","page":"Simulation Scenarios Analysis","title":"Obtain the thermal generation time series grouped by prime_mover","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"In some cases, it is more insightful to aggregate generation by prime_mover_type, in order to better understand the relative contributions of different generation technologies across the system.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"To achieve this, we modify our ComponentSelector using rebuild_selector, specifying groupby = get_prime_mover_type. This restructures the ComponentSelector so that thermal generators with the same prime_mover_type are grouped together.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"thermal_standard_selector_pm =\n    rebuild_selector(thermal_standard_selector; groupby = get_prime_mover_type)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Once we have this new ComponentSelector, we use the same metric defined in the previous subsection to compute the aggregated generation time series for each unique prime_mover_type.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"calc_active_power(thermal_standard_selector_pm, results_uc)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Identify-the-day-of-the-week-with-the-highest-total-thermal-generation-across-the-entire-system","page":"Simulation Scenarios Analysis","title":"Identify the day of the week with the highest total thermal generation across the entire system","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"To identify the day of the week with the highest total thermal generation across the system, we begin by creating a ComponentSelector that aggregates all ThermalStandard components into a single group. This is done by setting groupby = :all in make_selector, which considers all thermal generators as a unified entity and performs the desired spatial aggregation.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"thermal_standard_selector_sys = make_selector(ThermalStandard; groupby = :all)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We again use the PowerAnalytics.jl built-in calc_active_power metric in order to compute the active power time series for this aggregated group.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"The resulting dataframe contains the single time series representing the total thermal generation across all thermal generators in the system.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"sys_active_power = calc_active_power(thermal_standard_selector_sys, results_uc)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Since our goal is to compare generation values across the days of the week, we perform a temporal aggregation using aggregate_time. By passing groupby_fn = dayofweek as an argument, we group the data by day of the week (where 1= Monday, 2 = Tuesday, etc.), summing the total MWh generated on each weekday across the dataset.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"df_day = aggregate_time(sys_active_power; groupby_fn = dayofweek, groupby_col = \"agg_day\")","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Identify-the-top-10-hours-of-the-month-with-the-highest-storage-charging-values-for-each-Area","page":"Simulation Scenarios Analysis","title":"Identify the top 10 hours of the month with the highest storage charging values for each Area","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Spatially aggregating results by Area can reveal important spatial infromation and is frequently used for example in cases of transmission flow analysis. Area components often represent municipalities, villages or regional balancing areas of the real power system.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"In this subsection, we aim to identify the top 10 hours of the month with the highest values of storage charging for each Area of the system.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"To do this, we first define a ComponentSelector for all EnergyReservoirStorage components, but instead of grouping them individually, we group them by the name of the Area to which their bus belongs.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"storage_area_selector =\n    make_selector(EnergyReservoirStorage; groupby = (x -> get_name(get_area(get_bus(x)))))","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Next, using the ComponentSelector we created, we compute the total active power flowing into the storage components of each Area using calc_active_power_in, which is another one of PowerAnalytics.jl built-in metrics.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"df_charging = calc_active_power_in(storage_area_selector, results_uc)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We observe that the resulting dataframe has only a single column for Area \"3\". This is due to the fact that the RTS-GMLC test system contains only a single storage component, which is located in Area \"3\".","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We then iterate through each Area, sort its time series in descending order and extract the 10 timestamps with the highest charging values, an approach that is frequently used for storage capacity value calculations.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"area_columns = get_data_cols(df_charging)\nfor col in area_columns\n    top_10_df = sort(df_charging[:, [\"DateTime\", col]], col; rev = true)[1:10, :]\n\n    println(\"The top 10 hours of the month for Area $col are:\")\n    println(top_10_df)\n    println()\nend","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Computing-multiple-metrics-at-once","page":"Simulation Scenarios Analysis","title":"Computing multiple metrics at once","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We can efficiently compute multiple metrics and add their time series in the same summary table by using the compute_all function. In this case, we are interested in the three most common storage PowerAnalytics.jl built-in metrics:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"calc_active_power_in: charging power into the storage device\ncalc_active_power_out: active power output of the storage device\ncalc_stored_energy: amount of energy stored","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We can reuse the storage_area_selector defined in the previous subsection to perform spatial aggregation by Area. However, since we need to guarantee that each of the three metrics contributes only a single column to the resulting summary table, we'll adjust the selector’s grouping using rebuild_selector to aggregate the time series across all storage components in the system, rather than by Area.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"df = compute_all(results_uc,\n    (\n        calc_active_power_in,\n        rebuild_selector(storage_area_selector; groupby = :all),\n        \"Storage Charging\",\n    ),\n    (\n        calc_active_power_out,\n        rebuild_selector(storage_area_selector; groupby = :all),\n        \"Storage Discharging\",\n    ),\n    (\n        calc_stored_energy,\n        rebuild_selector(storage_area_selector; groupby = :all),\n        \"Stored Energy\",\n    ),\n);\nshow(df; allcols = true)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/#Multiple-Scenarios'-Results","page":"Simulation Scenarios Analysis","title":"Multiple Scenarios' Results","text":"","category":"section"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"In this section, instead of focusing on a single simulation scenario, we compare results across multiple scenarios. This allows us to explore how changing system component parameters can influence the simulation results.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We begin by creating two new selectors, which aggregate the results for all RenewableDispatch and EnergyReservoirStorage components respectively.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"renewable_dispatch_selector_sys = make_selector(RenewableDispatch; groupby = :all)\nstorage_selector_sys = make_selector(EnergyReservoirStorage; groupby = :all)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Next, we list all the PowerAnalytics.jl built-in metrics that will be computed for each timestep:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"calc_active_power\ncalc_curtailment\ncalc_active_power_in\ncalc_active_power_out\ncalc_stored_energy","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We then associate the defined selectors with the PowerAnalytics.jl built-in metrics in the vector time_computations, in order to compute the active power of the thermal generators, the total curtailment of the renewable generators and three storage specific metrics.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"time_computations = [\n    (calc_active_power, thermal_standard_selector_sys, \"Thermal Generation (MWh)\"),\n    (calc_curtailment, renewable_dispatch_selector_sys, \"Renewables Curtailment (MWh)\"),\n    (calc_active_power_in, storage_selector_sys, \"Storage Charging (MWh)\"),\n    (calc_active_power_out, storage_selector_sys, \"Storage Discharging (MWh)\"),\n    (calc_stored_energy, storage_selector_sys, \"Storage SOC (MWh)\"),\n]","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We are also interested in a set of metrics that are not available as time series, which we define in timeless_computations. These include the:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"objective value\ncumulative solve time\ntotal memory allocated during the simulation","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"timeless_computations =\n    [calc_sum_objective_value, calc_sum_solve_time, calc_sum_bytes_alloc]\ntimeless_names = [\"Objective Value\", \"Solve Time (s)\", \"Memory Allocated\"];","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"tip: Tip\nUnderstanding memory usage across simulations is often particularly helpful when working with larger system models on NREL's HPC systems, since it can inform decisions regarding resource allocation, such as choosing between standard and high-memory partitions in order to avoid out-of-memory (OOM) errors.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Next, we define two utility functions, which form the core of our multi-scenario analysis pipeline and are executed for each individual scenario, namely:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"analyze_one: an analytics routine that takes in the desired time-based and timeless metrics as arguments. It computes the selected time series metrics, aggregates them over time, and appends the timeless metrics into a unified summary table.\nsave_one: saves the outputs from analyze_one to disk","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"function analyze_one(results)\n    time_series_analytics = compute_all(results, time_computations...)\n    aggregated_time = aggregate_time(time_series_analytics)\n    computed_all = compute_all(results, timeless_computations, nothing, timeless_names)\n    all_time_analytics = hcat(aggregated_time, computed_all)\n    return time_series_analytics, all_time_analytics\nend\n\nfunction save_one(output_dir, time_series_analytics, all_time_analytics)\n    CSV.write(joinpath(output_dir, \"summary_dataframe.csv\"), time_series_analytics)\n    CSV.write(joinpath(output_dir, \"summary_stats.csv\"), all_time_analytics)\nend","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Finally, we define the main post-processing routine that runs across all scenarios. After processing all scenarios, it concatenates the summaries into a single dataframe, which also gets exported to a csv file.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"function post_processing(all_results)\n    summaries = DataFrame[]\n    for (scenario_name, results) in pairs(all_results)\n        println(\"Computing for scenario: \", scenario_name)\n        (time_series_analytics, all_time_analytics) = analyze_one(results)\n        save_one(results.results_output_folder, time_series_analytics, all_time_analytics)\n        push!(summaries, hcat(DataFrame(\"Scenario\" => scenario_name), all_time_analytics))\n    end\n\n    summaries_df = vcat(summaries...)\n    CSV.write(\"all_scenarios_summary.csv\", summaries_df)\n    return summaries_df\nend","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"We run the post_processing routine with our multi-scenario results we previously defined. We can see the final summary table including all scenarios below:","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"df = post_processing(results_all);\nshow(df; allcols = true)","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Looking at the final dataframe, we can now easily compare the aggregated results of the selected metrics between the two simulation scenarios.","category":"page"},{"location":"tutorials/PA_workflow_tutorial/","page":"Simulation Scenarios Analysis","title":"Simulation Scenarios Analysis","text":"Focusing on the thermal generation and renewable curtailment results for example, we observe a decrease of approximately 0.15% in total thermal generation and approximately 11.90% in renewable curtailment across the full simulation horizon and the entire system. The increased energy capacity of the storage device in the second scenario enables it to store more excess renewable energy rather than curtail it, which in turn reduces the need for thermal generation.","category":"page"},{"location":"reference/public/#Public-API-Reference","page":"Public API","title":"Public API Reference","text":"","category":"section"},{"location":"reference/public/#ComponentSelector","page":"Public API","title":"ComponentSelector","text":"","category":"section"},{"location":"reference/public/","page":"Public API","title":"Public API","text":"PowerAnalytics depends heavily on the ComponentSelector feature of PowerSystems.jl. ComponentSelector documentation can be found here. PowerAnalytics provides some built-in selectors, but much of the power of PowerAnalytics comes from the ability to operate on custom ComponentSelectors.","category":"page"},{"location":"reference/public/#Input-Utilities","page":"Public API","title":"Input Utilities","text":"","category":"section"},{"location":"reference/public/#PowerAnalytics.create_problem_results_dict","page":"Public API","title":"PowerAnalytics.create_problem_results_dict","text":"create_problem_results_dict(\n    results_dir::AbstractString,\n    problem::String;\n    ...\n) -> DataStructures.SortedDict{Any, Any, Base.Order.ForwardOrdering}\ncreate_problem_results_dict(\n    results_dir::AbstractString,\n    problem::String,\n    scenarios::Union{Nothing, Vector{<:AbstractString}};\n    populate_system,\n    kwargs...\n) -> DataStructures.SortedDict{Any, Any, Base.Order.ForwardOrdering}\n\n\nAccept a directory that contains several results subdirectories (that each contain results, problems, etc. sub-subdirectories) and construct a sorted dictionary from String to PowerSimulations.SimulationProblemResults where the keys are the subdirectory names and the values are loaded results datasets.\n\nArguments\n\nresults_dir::AbstractString: the directory where results subdirectories can be found\nproblem::String: the name of the problem to load (e.g., UC, ED)\nscenarios::Union{Vector{AbstractString}, Nothing} = nothing: a list of scenario subdirectories to load, or nothing to load all the subdirectories\npopulate_system::Bool = false: whether to automatically load and attach the system; errors if true and the system has not been saved with the results. This keyword argument is false by default for backwards compatibility, but most PowerAnalytics functionality requires results to have an attached system, so users should typically pass populate_system = true.\nkwargs...: further keyword arguments to pass through to get_decision_problem_results\n\nExamples\n\nSuppose we have the directory data_root with subdirectories results1, results2, and results3, where each of these subdirectories contains problems/UC. Then:\n\n# Load results for only `results1` and `results2`:\ncreate_problem_results_dict(data_root, \"UC\", [\"results1\", \"results2\"]; populate_system = true)\n# Load results for all three scenarios:\ncreate_problem_results_dict(data_root, \"UC\"; populate_system = true)\n\nSee also\n\ncreate_problem_results_dict is a convenience function that calls public interface in PowerSimulations.jl. To read one results set, or several of them that are not all in the same parent directory, invoke that interface directly as needed:\n\n# Load a single results set\nPowerSimulations.get_decision_problem_results(\n    PowerSimulations.SimulationResults(path_to_individual_results),\n    problem_name; populate_system = true)\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#Basic-Metric-Interface","page":"Public API","title":"Basic Metric Interface","text":"","category":"section"},{"location":"reference/public/","page":"Public API","title":"Public API","text":"The basic Metric interface consists of calling a Metric itself, for computing one Metric at a time, and the compute_all function for bulk computation. Combined with PowerAnalytics' built-in metrics, this is enough to execute many common computations. See Advanced Metrics Interface for the interface to create custom Metrics.","category":"page"},{"location":"reference/public/#PowerAnalytics.Metric","page":"Public API","title":"PowerAnalytics.Metric","text":"A PowerAnalytics Metric specifies how to compute a useful quantity, like active power or curtailment, from a set of results. Many but not all Metrics require a ComponentSelector to specify which available components of the system the quantity should be computed on, and many but not all Metrics return time series results. In addition to how to compute the output — which may be as simple as looking up a variable or parameter in the results but may involve actual computation — Metrics encapsulate default component-wise and time-wise aggregation behaviors. Metrics can be \"called\" like functions.\n\nPowerAnalytics provides a library of pre-built Metrics, PowerAnalytics.Metrics; users may also build their own. In most cases of custom metric creation, it should suffice to instantiate one of the concrete Metric subtypes PowerAnalytics provides; in special cases, the user can create their own subtype that implements compute.\n\nExamples\n\nGiven a PowerSimulations.SimulationProblemResults results:\n\nusing PowerAnalytics.Metrics\n\n# Call the built-in `Metric` `calc_active_power` on a `ComponentSelector` to get a\n# `DataFrame` of results, where the columns are the groups in the `ComponentSelector` and\n# the rows are time:\ncalc_active_power(make_selector(RenewableDispatch), results)\n\n# Call the built-in `Metric` `calc_system_slack_up`, which refers to the whole system so\n# doesn't need a `ComponentSelector`:\ncalc_system_slack_up(results)\n\n\n\n\n\n","category":"type"},{"location":"reference/public/#PowerAnalytics.TimedMetric","page":"Public API","title":"PowerAnalytics.TimedMetric","text":"Metrics that return time series.\n\n\n\n\n\n","category":"type"},{"location":"reference/public/#PowerAnalytics.TimelessMetric","page":"Public API","title":"PowerAnalytics.TimelessMetric","text":"Metrics that do not return time series.\n\n\n\n\n\n","category":"type"},{"location":"reference/public/#PowerAnalytics.compute_all","page":"Public API","title":"PowerAnalytics.compute_all","text":"compute_all(\n    results::InfrastructureSystems.Results,\n    metrics::Vector{<:TimelessMetric};\n    ...\n) -> Any\ncompute_all(\n    results::InfrastructureSystems.Results,\n    metrics::Vector{<:TimelessMetric},\n    selectors::Union{Nothing, ComponentSelector, Component, Vector};\n    ...\n) -> Any\ncompute_all(\n    results::InfrastructureSystems.Results,\n    metrics::Vector{<:TimelessMetric},\n    selectors::Union{Nothing, ComponentSelector, Component, Vector},\n    col_names::Union{Nothing, Vector{<:Union{Nothing, AbstractString}}};\n    kwargs...\n) -> Any\n\n\nMethods of compute_all for TimelessMetrics. For each (metric, selector, col_name) tuple in zip(metrics, selectors, col_names), call compute and collect the results in a DataFrame. All selectors must yield exactly one group.\n\nArguments\n\nresults::IS.Results: the results from which to fetch data\nmetrics::Vector{<:TimelessMetric}: the metrics to compute\nselectors: either a scalar or vector of Nothing/Component/ComponentSelector: the selectors on which to compute the metrics, or nothing for system/results metrics; broadcast if scalar\ncol_names::Union{Nothing, Vector{<:Union{Nothing, AbstractString}}} = nothing: a vector of names for the columns of output data. Entries of nothing default to the result of metric_selector_to_string; names = nothing is equivalent to an entire vector of nothing\nkwargs...: pass through to each compute call\n\nExamples\n\nGiven a results with the proper data:\n\nusing PowerAnalytics.Metrics\ncompute_all(results,\n    [calc_sum_objective_value, calc_sum_solve_time],\n    [nothing, nothing],\n    [\"objective_value\", \"solve_time\"]\n)  # returns an 1x2 DataFrame with columns `objective_value` and `solve_time`\n\nSee also: compute_all tuple-based interface\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.compute_all-2","page":"Public API","title":"PowerAnalytics.compute_all","text":"compute_all takes several metrics, single-group ComponentSelectors if relevant, and optionally column names and produces a single table with all the output for a given results set. It can be useful to quickly put together a summary statistics table.\n\nExamples\n\nSee the methods.\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.compute_all-3","page":"Public API","title":"PowerAnalytics.compute_all","text":"compute_all(\n    results::InfrastructureSystems.Results,\n    metrics::Vector{<:TimedMetric};\n    ...\n) -> Any\ncompute_all(\n    results::InfrastructureSystems.Results,\n    metrics::Vector{<:TimedMetric},\n    selectors::Union{Nothing, ComponentSelector, Component, Vector};\n    ...\n) -> Any\ncompute_all(\n    results::InfrastructureSystems.Results,\n    metrics::Vector{<:TimedMetric},\n    selectors::Union{Nothing, ComponentSelector, Component, Vector},\n    col_names::Union{Nothing, Vector{<:Union{Nothing, AbstractString}}};\n    kwargs...\n) -> Any\n\n\nMethods of compute_all for TimedMetrics. For each (metric, selector, col_name) tuple in zip(metrics, selectors, col_names), call compute and collect the results in a DataFrame with a single DateTime column. All selectors must yield exactly one group.\n\nArguments\n\nresults::IS.Results: the results from which to fetch data\nmetrics::Vector{<:TimedMetric}: the metrics to compute\nselectors: either a scalar or vector of Nothing/Component/ComponentSelector: the selectors on which to compute the metrics, or nothing for system/results metrics; broadcast if scalar\ncol_names::Union{Nothing, Vector{<:Union{Nothing, AbstractString}}} = nothing: a vector of names for the columns of output data. Entries of nothing default to the result of metric_selector_to_string; names = nothing is equivalent to an entire vector of nothing\nkwargs...: pass through to each compute call\n\nExamples\n\nGiven a results with the proper data:\n\nusing PowerAnalytics.Metrics\ncompute_all(results,\n    [calc_active_power, calc_curtailment],\n    [make_selector(ThermalStandard; groupby = :all), make_selector(RenewableDispatch; groupby = :all)],\n    [\"thermal_power\", \"renewable_curtailment\"]\n)  # returns an 8760x3 DataFrame with columns `DateTime`, `thermal_power`, and `renewable_curtailment`\n\nSee also: compute_all tuple-based interface\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.compute_all-Tuple{InfrastructureSystems.Results, Vararg{Tuple{Union{TimedMetric, TimelessMetric}, Any, Any}}}","page":"Public API","title":"PowerAnalytics.compute_all","text":"compute_all(\n    results::InfrastructureSystems.Results,\n    computations::Tuple{Union{TimedMetric, TimelessMetric}, Any, Any}...;\n    kwargs...\n) -> Any\n\n\nFor convenience, a variant signature of compute_all where the metrics, selectors, and column names are specified as a list of tuples rather than three separate lists.\n\nArguments\n\nresults::IS.Results: the results from which to fetch data\ncomputations::(Tuple{<:T, Any, Any} where T <: Union{TimedMetric, TimelessMetric})...: a list of the computations to perform, where each element is a (metric, selector, col_name) where metric is the metric to compute, selector is the ComponentSelector on which to compute the metric or nothing if not relevant, and col_name is the name for the output column of data or nothing to use the default\nkwargs...: pass through to each compute call\n\nExamples\n\nGiven a results with the proper data:\n\nmy_computations = [\n    (calc_active_power, make_selector(ThermalStandard; groupby = :all), \"thermal_power\"),\n    (calc_curtailment, make_selector(RenewableDispatch; groupby = :all), \"renewable_curtailment\")\n]\ncompute_all(results, my_computations...)\n\n# The above is equivalent to\ncompute_all(results,\n    [calc_active_power, calc_curtailment],\n    [make_selector(ThermalStandard; groupby = :all), make_selector(RenewableDispatch; groupby = :all)],\n    [\"thermal_power\", \"renewable_curtailment\"]\n)\n\nSee also: compute_all non-tuple-based interface\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#Built-in-Metrics","page":"Public API","title":"Built-in Metrics","text":"","category":"section"},{"location":"reference/public/#Metrics-Submodule","page":"Public API","title":"Metrics Submodule","text":"","category":"section"},{"location":"reference/public/","page":"Public API","title":"Public API","text":"Here is defined a \"library\" of built-in metrics to execute many common power systems post-processing calculations.","category":"page"},{"location":"reference/public/#PowerAnalytics.Metrics","page":"Public API","title":"PowerAnalytics.Metrics","text":"PowerAnalytics built-in Metrics. Use names to list what is available.\n\nExamples\n\nusing PowerAnalytics\nnames(PowerAnalytics.Metrics)  # lists built-in Metrics\nPowerAnalytics.Metrics.calc_active_power  # by default, must prefix built-in Metrics with the module name\n@isdefined calc_active_power  # -> false\nusing PowerAnalytics.Metrics\n@isdefined calc_active_power  # -> true, can now refer to built-in Metrics without the prefix\n\n\n\n\n\n","category":"module"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_active_power","page":"Public API","title":"PowerAnalytics.Metrics.calc_active_power","text":"Calculate the active power of the specified ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_active_power_forecast","page":"Public API","title":"PowerAnalytics.Metrics.calc_active_power_forecast","text":"Fetch the forecast active power of the specified ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_active_power_in","page":"Public API","title":"PowerAnalytics.Metrics.calc_active_power_in","text":"Calculate the active power input to the specified (storage) ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_active_power_out","page":"Public API","title":"PowerAnalytics.Metrics.calc_active_power_out","text":"Calculate the active power output of the specified (storage) ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_capacity_factor","page":"Public API","title":"PowerAnalytics.Metrics.calc_capacity_factor","text":"Calculate the capacity factor (actual production/rated production) of the specified ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_curtailment","page":"Public API","title":"PowerAnalytics.Metrics.calc_curtailment","text":"Calculate the ActivePowerForecast minus the ActivePower of the given ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_curtailment_frac","page":"Public API","title":"PowerAnalytics.Metrics.calc_curtailment_frac","text":"Calculate the curtailment as a fraction of the ActivePowerForecast of the given ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_discharge_cycles","page":"Public API","title":"PowerAnalytics.Metrics.calc_discharge_cycles","text":"Calculate the number of discharge cycles a storage device has gone through in the time period\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_integration","page":"Public API","title":"PowerAnalytics.Metrics.calc_integration","text":"Calculate the ActivePower of the given ComponentSelector over the sum of the SystemLoadForecast and the SystemLoadFromStorage\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_is_slack_up","page":"Public API","title":"PowerAnalytics.Metrics.calc_is_slack_up","text":"Calculate whether the given time period has system balance slack up of magnitude greater than 0.0001\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_load_forecast","page":"Public API","title":"PowerAnalytics.Metrics.calc_load_forecast","text":"Fetch the forecast active load of the specified ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_load_from_storage","page":"Public API","title":"PowerAnalytics.Metrics.calc_load_from_storage","text":"Calculate the ActivePowerIn minus the ActivePowerOut of the specified (storage) ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_net_load_forecast","page":"Public API","title":"PowerAnalytics.Metrics.calc_net_load_forecast","text":"SystemLoadForecast minus ActivePowerForecast of the given ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_production_cost","page":"Public API","title":"PowerAnalytics.Metrics.calc_production_cost","text":"Calculate the active power output of the specified ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_shutdown_cost","page":"Public API","title":"PowerAnalytics.Metrics.calc_shutdown_cost","text":"Calculate the shutdown cost of the specified ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_startup_cost","page":"Public API","title":"PowerAnalytics.Metrics.calc_startup_cost","text":"Calculate the startup cost of the specified ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_stored_energy","page":"Public API","title":"PowerAnalytics.Metrics.calc_stored_energy","text":"Calculate the energy stored in the specified (storage) ComponentSelector\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_sum_bytes_alloc","page":"Public API","title":"PowerAnalytics.Metrics.calc_sum_bytes_alloc","text":"Sum the bytes allocated to the optimization problems\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_sum_objective_value","page":"Public API","title":"PowerAnalytics.Metrics.calc_sum_objective_value","text":"Sum the objective values achieved in the optimization problems\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_sum_solve_time","page":"Public API","title":"PowerAnalytics.Metrics.calc_sum_solve_time","text":"Sum the solve times taken by the optimization problems\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_system_load_forecast","page":"Public API","title":"PowerAnalytics.Metrics.calc_system_load_forecast","text":"Fetch the forecast active load of all the ElectricLoad Components in the system\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_system_load_from_storage","page":"Public API","title":"PowerAnalytics.Metrics.calc_system_load_from_storage","text":"Fetch the LoadFromStorage of all storage in the system\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_system_slack_up","page":"Public API","title":"PowerAnalytics.Metrics.calc_system_slack_up","text":"Calculate the system balance slack up\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Metrics.calc_total_cost","page":"Public API","title":"PowerAnalytics.Metrics.calc_total_cost","text":"Calculate the production cost of the specified ComponentSelector, plus the startup and shutdown costs if they are defined\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#Built-in-Selectors","page":"Public API","title":"Built-in Selectors","text":"","category":"section"},{"location":"reference/public/#Selector-Utilities","page":"Public API","title":"Selector Utilities","text":"","category":"section"},{"location":"reference/public/#PowerAnalytics.parse_generator_categories","page":"Public API","title":"PowerAnalytics.parse_generator_categories","text":"parse_generator_categories(\n    filename;\n    root_type\n) -> Union{Nothing, Dict{String, ComponentSelector}}\n\n\nUse parse_generator_mapping_file to parse a generator_mapping.yaml file into a dictionary of ComponentSelectors, excluding categories in the 'non_generators' list in metadata.\n\nArguments\n\nfilename: the path to the generator_mapping.yaml file\nroot_type::Type{<:Component} = PSY.StaticInjection: the Component type assumed in cases where there is no more precise information\n\nSee also: parse_injector_categories if all injectors are desired\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.parse_generator_mapping_file","page":"Public API","title":"PowerAnalytics.parse_generator_mapping_file","text":"parse_generator_mapping_file(\n    filename;\n    root_type\n) -> Tuple{Dict{String, ComponentSelector}, Any}\n\n\nParse a generator_mapping.yaml file into a dictionary of ComponentSelectors and a dictionary of metadata if present.\n\nArguments\n\nfilename: the path to the generator_mapping.yaml file\nroot_type::Type{<:Component} = PSY.StaticInjection: the Component type assumed in cases where there is no more precise information\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.parse_injector_categories","page":"Public API","title":"PowerAnalytics.parse_injector_categories","text":"parse_injector_categories(\n    filename;\n    root_type\n) -> Dict{String, ComponentSelector}\n\n\nUse parse_generator_mapping_file to parse a generator_mapping.yaml file into a dictionary of all ComponentSelectors.\n\nArguments\n\nfilename: the path to the generator_mapping.yaml file\nroot_type::Type{<:Component} = PSY.StaticInjection: the Component type assumed in cases where there is no more precise information\n\nSee also: parse_generator_categories if only generators are desired\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#Selectors-Submodule","page":"Public API","title":"Selectors Submodule","text":"","category":"section"},{"location":"reference/public/#PowerAnalytics.Selectors","page":"Public API","title":"PowerAnalytics.Selectors","text":"PowerAnalytics built-in ComponentSelectors. Use names to list what is available.\n\nExamples\n\nusing PowerAnalytics\nnames(PowerAnalytics.Selectors)  # lists built-in selectors\nPowerAnalytics.Selectors.all_loads  # by default, must prefix built-in selectors with the module name\n@isdefined all_loads  # -> false\nusing PowerAnalytics.Selectors\n@isdefined all_loads  # -> true, can now refer to built-in selectors without the prefix\n\n\n\n\n\n","category":"module"},{"location":"reference/public/#PowerAnalytics.Selectors.all_loads","page":"Public API","title":"PowerAnalytics.Selectors.all_loads","text":"A ComponentSelector representing all the electric load in a System\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Selectors.all_storage","page":"Public API","title":"PowerAnalytics.Selectors.all_storage","text":"A ComponentSelector representing all the storage in a System\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Selectors.categorized_generators","page":"Public API","title":"PowerAnalytics.Selectors.categorized_generators","text":"A single ComponentSelector representing the generators in a System (no storage or load) grouped by the categories in generator_mapping.yaml\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Selectors.categorized_injectors","page":"Public API","title":"PowerAnalytics.Selectors.categorized_injectors","text":"A single ComponentSelector representing the static injectors in a System grouped by the categories in generator_mapping.yaml\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Selectors.generator_categories","page":"Public API","title":"PowerAnalytics.Selectors.generator_categories","text":"A dictionary of ComponentSelectors, each of which corresponds to one of the categories in generator_mapping.yaml, only considering the components and categories that represent generators (no storage or load)\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.Selectors.injector_categories","page":"Public API","title":"PowerAnalytics.Selectors.injector_categories","text":"A dictionary of ComponentSelectors, each of which corresponds to one of the static injector categories in generator_mapping.yaml\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#Post-Metric-Utilities","page":"Public API","title":"Post-Metric Utilities","text":"","category":"section"},{"location":"reference/public/","page":"Public API","title":"Public API","text":"Post-processing on the specially formatted DataFrames that Metrics produce.","category":"page"},{"location":"reference/public/#PowerAnalytics.aggregate_time","page":"Public API","title":"PowerAnalytics.aggregate_time","text":"aggregate_time(\n    df::DataFrames.AbstractDataFrame;\n    groupby_fn,\n    groupby_col,\n    agg_fn\n) -> Any\n\n\nGiven a DataFrame like that produced by a TimedMetric or the timed version of compute_all, group by a function of the time axis, apply a reduction, and report the resulting aggregation indexed by the first timestamp in each group.\n\nArguments\n\ndf::DataFrames.AbstractDataFrame: the DataFrame to operate upon\ngroupby_fn = nothing: a function that can be passed a DateTime; two rows will be in the same group if their timestamps produce the same result under groupby_fn. Note that groupby_fn = month puts January 2024 and January 2025 into the same group whereas groupby_fn = (x -> (year(x), month(x))) does not. Passing nothing groups all rows in the DataFrame together.\ngroupby_col::Union{Nothing, AbstractString, Symbol} = nothing: specify a column name to report the result of groupby_fn in the output DataFrame, or nothing to not\nagg_fn = nothing: by default, the aggregation function (sum/mean/etc.) is specified by the Metric, which is read from the metadata of each column. If this metadata isn't found, one can specify a default aggregation function like sum here; if nothing, an error will be thrown.\n\nExamples\n\nusing Dates\nusing PowerAnalytics.Metrics\n# Setup: create a `DataFrame` to work with\nmy_computations = [\n    (calc_active_power, make_selector(ThermalStandard; groupby = :all), \"thermal_power\"),\n    (calc_curtailment, make_selector(RenewableDispatch; groupby = :all), \"renewable_curtailment\")\n]\nmy_8760 = compute_all(results, my_computations...)\n# Now (given a certain simulation setup) `my_8760` is an 8760x3 DataFrame\n# with columns `DateTime`, `thermal_power`, and `renewable_curtailment`\n\n# Aggregate across the entire time period; result is 1x3:\naggregate_time(my_8760)\n\n# Aggregate all January results together, all February results together, etc.; result is 12x3:\naggregate_time(my_8760; groupby_fn = Dates.month)\n\n# Same as above but create a column 'month_n' with 1 for January, 2 for February, etc.; result is 12x4:\naggregate_time(my_8760; groupby_fn = Dates.month, groupby_col = \"month_n\")\n\n# Custom `groupby_fn`: put all weekday timestamps together and all weekend timestamps together; result is 2x4:\naggregate_time(my_8760; groupby_fn = x -> (Dates.dayofweek(x) in [6, 7]) ? \"weekend\" : \"weekday\", groupby_col = \"day_type\")\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.hcat_timed_dfs","page":"Public API","title":"PowerAnalytics.hcat_timed_dfs","text":"hcat_timed_dfs(vals::DataFrames.DataFrame...) -> Any\n\n\nIf the time axes match across all the DataFrames, horizontally concatenate them and remove the duplicate time axes. If not, throw an error.\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#Post-Metric-Accessors","page":"Public API","title":"Post-Metric Accessors","text":"","category":"section"},{"location":"reference/public/","page":"Public API","title":"Public API","text":"Extract and manipulate information from the specially formatted DataFrames that Metrics produce.","category":"page"},{"location":"reference/public/#PowerAnalytics.get_agg_meta-Tuple{Any, Any}","page":"Public API","title":"PowerAnalytics.get_agg_meta","text":"get_agg_meta(df, colname) -> Any\n\n\nGet the column's aggregation metadata; return nothing if there is none.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.get_agg_meta-Tuple{Any}","page":"Public API","title":"PowerAnalytics.get_agg_meta","text":"get_agg_meta(df) -> Any\n\n\nGet the single data column's aggregation metadata; error on multiple data columns.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.get_data_cols-Tuple{DataFrames.AbstractDataFrame}","page":"Public API","title":"PowerAnalytics.get_data_cols","text":"get_data_cols(\n    df::DataFrames.AbstractDataFrame\n) -> Vector{String}\n\n\nSelect the names of the data columns of the DataFrame, i.e., those that are not DateTime and not metadata.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.get_data_df-Tuple{DataFrames.AbstractDataFrame}","page":"Public API","title":"PowerAnalytics.get_data_df","text":"get_data_df(df::DataFrames.AbstractDataFrame) -> Any\n\n\nSelect the data columns of the DataFrame as a DataFrame without copying.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.get_data_mat-Tuple{DataFrames.AbstractDataFrame}","page":"Public API","title":"PowerAnalytics.get_data_mat","text":"get_data_mat(df::DataFrames.AbstractDataFrame) -> Any\n\n\nSelect the data columns of the DataFrame as a Matrix with copying.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.get_data_vec-Tuple{DataFrames.AbstractDataFrame}","page":"Public API","title":"PowerAnalytics.get_data_vec","text":"get_data_vec(df::DataFrames.AbstractDataFrame) -> Any\n\n\nSelect the data column of the DataFrame as a vector without copying, errors if more than one.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.get_time_df-Tuple{DataFrames.AbstractDataFrame}","page":"Public API","title":"PowerAnalytics.get_time_df","text":"get_time_df(df::DataFrames.AbstractDataFrame) -> Any\n\n\nSelect the DateTime column of the DataFrame as a one-column DataFrame without copying.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.get_time_vec-Tuple{DataFrames.AbstractDataFrame}","page":"Public API","title":"PowerAnalytics.get_time_vec","text":"get_time_vec(df::DataFrames.AbstractDataFrame) -> Any\n\n\nSelect the DateTime column of the DataFrame as a Vector without copying.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.is_col_meta-Tuple{Any, Any}","page":"Public API","title":"PowerAnalytics.is_col_meta","text":"is_col_meta(df, colname) -> Any\n\n\nCheck whether a column is metadata.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.set_agg_meta!-Tuple{Any, Any, Any}","page":"Public API","title":"PowerAnalytics.set_agg_meta!","text":"set_agg_meta!(\n    df,\n    colname,\n    val\n) -> Union{DataFrames.DataFrame, DataFrames.DataFrameColumns, DataFrames.DataFrameRow, DataFrames.DataFrameRows, DataFrames.SubDataFrame}\n\n\nSet the column's aggregation metadata.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.set_agg_meta!-Tuple{Any, Any}","page":"Public API","title":"PowerAnalytics.set_agg_meta!","text":"set_agg_meta!(\n    df,\n    val\n) -> Union{DataFrames.DataFrame, DataFrames.DataFrameColumns, DataFrames.DataFrameRow, DataFrames.DataFrameRows, DataFrames.SubDataFrame}\n\n\nSet the single data column's aggregation metadata; error on multiple data columns.\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.set_col_meta!","page":"Public API","title":"PowerAnalytics.set_col_meta!","text":"set_col_meta!(\n    df,\n    colname\n) -> Union{DataFrames.DataFrame, DataFrames.DataFrameColumns, DataFrames.DataFrameRow, DataFrames.DataFrameRows, DataFrames.SubDataFrame}\nset_col_meta!(\n    df,\n    colname,\n    val\n) -> Union{DataFrames.DataFrame, DataFrames.DataFrameColumns, DataFrames.DataFrameRow, DataFrames.DataFrameRows, DataFrames.SubDataFrame}\n\n\nMark a column as metadata.\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#Advanced-Metrics-Interface","page":"Public API","title":"Advanced Metrics Interface","text":"","category":"section"},{"location":"reference/public/#PowerAnalytics.ComponentSelectorTimedMetric","page":"Public API","title":"PowerAnalytics.ComponentSelectorTimedMetric","text":"TimedMetrics defined in terms of a ComponentSelector.\n\n\n\n\n\n","category":"type"},{"location":"reference/public/#PowerAnalytics.ComponentTimedMetric","page":"Public API","title":"PowerAnalytics.ComponentTimedMetric","text":"ComponentTimedMetric(name::String, eval_fn::Function, component_agg_fn::Function, time_agg_fn::Function, component_meta_agg_fn::Function, time_meta_agg_fn::Function, eval_zero::Union{Nothing, Function})\nComponentTimedMetric(; name, eval_fn, component_agg_fn, time_agg_fn, component_meta_agg_fn, time_meta_agg_fn, eval_zero)\n\nA ComponentSelectorTimedMetric implemented by evaluating a function on each Component.\n\nArguments\n\nname::String: the name of the Metric\neval_fn: a function with signature (::IS.Results, ::Component; start_time::Union{Nothing, DateTime}, len::Union{Int, Nothing}) that returns a DataFrame representing the results for that Component\ncomponent_agg_fn: optional, a function to aggregate results between Components/ComponentSelectors, defaults to sum\ntime_agg_fn: optional, a function to aggregate results across time, defaults to sum\ncomponent_meta_agg_fn: optional, a function to aggregate metadata across components, defaults to sum\ntime_meta_agg_fn: optional, a function to aggregate metadata across time, defaults to sum\neval_zero: optional and rarely filled in, specifies what to do in the case where there are no components to contribute to a particular group; defaults to nothing, in which case the data is filled in from the identity element of component_agg_fn\n\n\n\n\n\n","category":"type"},{"location":"reference/public/#PowerAnalytics.CustomTimedMetric","page":"Public API","title":"PowerAnalytics.CustomTimedMetric","text":"CustomTimedMetric(name::String, eval_fn::Function, time_agg_fn::Function, time_meta_agg_fn::Function)\nCustomTimedMetric(; name, eval_fn, time_agg_fn, time_meta_agg_fn)\n\nA ComponentSelectorTimedMetric implemented without drilling down to the base Components, just calls the eval_fn directly on the ComponentSelector.\n\nArguments\n\nname::String: the name of the Metric\neval_fn: a function with signature (::IS.Results, ::Union{ComponentSelector, Component}; start_time::Union{Nothing, DateTime}, len::Union{Int, Nothing}) that returns a DataFrame representing the results for that Component\ntime_agg_fn: optional, a function to aggregate results across time, defaults to sum\ntime_meta_agg_fn: optional, a function to aggregate metadata across time, defaults to sum\n\n\n\n\n\n","category":"type"},{"location":"reference/public/#PowerAnalytics.ResultsTimelessMetric","page":"Public API","title":"PowerAnalytics.ResultsTimelessMetric","text":"ResultsTimelessMetric(name::String, eval_fn::Function)\nResultsTimelessMetric(; name, eval_fn)\n\nA TimelessMetric with a single value per IS.Results instance.\n\nArguments\n\nname::String: the name of the Metric\neval_fn: a function with signature (::IS.Results,) that returns a DataFrame representing the results\n\n\n\n\n\n","category":"type"},{"location":"reference/public/#PowerAnalytics.SystemTimedMetric","page":"Public API","title":"PowerAnalytics.SystemTimedMetric","text":"SystemTimedMetric(name::String, eval_fn::Function, time_agg_fn::Function, time_meta_agg_fn::Function)\nSystemTimedMetric(; name, eval_fn, time_agg_fn, time_meta_agg_fn)\n\nA TimedMetric that calculates an output for an entire System embedded in a set of results.\n\nArguments\n\nname::String: the name of the Metric\neval_fn: a function with signature (::IS.Results; start_time::Union{Nothing, DateTime}, len::Union{Int, Nothing}) that returns a DataFrame representing the results\ntime_agg_fn: optional, a function to aggregate results across time, defaults to sum\ntime_meta_agg_fn: optional, a function to aggregate metadata across time, defaults to sum\n\n\n\n\n\n","category":"type"},{"location":"reference/public/#PowerAnalytics.rebuild_metric","page":"Public API","title":"PowerAnalytics.rebuild_metric","text":"rebuild_metric(metric::Metric; kwargs...) -> Any\n\n\nReturns a new Metric identical to the input metric except with the changes to its fields specified in the keyword arguments. See the Metric constructors (e.g., ComponentTimedMetric) for available fields to alter.\n\nExamples\n\nMake a variant of calc_active_power that averages across components rather than summing:\n\nusing PowerAnalytics.Metrics\nconst calc_active_power_mean = rebuild_metric(calc_active_power; component_agg_fn = mean)\n# Now calc_active_power_mean works as a standalone, callable metric:\ncalc_active_power_mean(make_selector(RenewableDispatch), results)\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.compose_metrics","page":"Public API","title":"PowerAnalytics.compose_metrics","text":"Given a list of metrics and a function that applies to their results to produce one result, create a new metric that computes the sub-metrics and applies the function to produce its own result.\n\nArguments\n\nname::String: the name of the new Metric\nreduce_fn: a function that takes one value from each of the input Metrics and returns a single value that will be the result of this Metric. \"Value\" means a vector (not a DataFrame) in the case of TimedMetrics and a scalar for TimelessMetrics.\nmetrics: the input Metrics. It is currently not possible to combine TimedMetrics with TimelessMetrics, though it is possible to combine ComponentSelectorTimedMetrics with SystemTimedMetrics.\n\nExamples\n\nThis is the implementation of the built-in metric calc_load_from_storage, which computes the preexisting built-in metrics calc_active_power_in and calc_active_power_out and combines them by subtraction:\n\nconst calc_load_from_storage = compose_metrics(\n    \"LoadFromStorage\",\n    (-),\n    calc_active_power_in, calc_active_power_out)\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.compute","page":"Public API","title":"PowerAnalytics.compute","text":"The compute function is the most important part of the Metric interface. Calling a metric as if it were a function is syntactic sugar for calling compute:\n\n# this:\nmy_metric1(selector, results; kwargs)\n# is the same as this:\ncompute(my_metric1, results, selector; kwargs)\n\n# and this:\nmy_metric2(results; kwargs)\n# is the same as this:\ncompute(my_metric2; kwargs)\n\nExact keyword arguments and formatting of the resulting DataFrame are documented for each of the existing methods, below. Custom Metric subtypes must implement this function.\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}","page":"Public API","title":"PowerAnalytics.compute","text":"compute(\n    metric::ComponentTimedMetric,\n    results::InfrastructureSystems.Results,\n    selector::ComponentSelector;\n    kwargs...\n) -> Any\n\n\ncompute method for ComponentTimedMetric. Compute the given metric on the groups of the given ComponentSelector within the given set of results, returning a DataFrame with a DateTime column and a data column for each group. Exclude components marked as not available.\n\nArguments\n\nmetric::ComponentTimedMetric: the metric to compute\nresults::IS.Results: the results from which to fetch data\nselector::ComponentSelector: the ComponentSelector on whose subselectors to compute the metric\nstart_time::Union{Nothing, DateTime} = nothing: the time at which the resulting time series should begin\nlen::Union{Int, Nothing} = nothing: the number of steps in the resulting time series\n\nSee also: compute unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, Component}","page":"Public API","title":"PowerAnalytics.compute","text":"compute(\n    metric::ComponentTimedMetric,\n    results::InfrastructureSystems.Results,\n    comp::Component;\n    kwargs...\n) -> Any\n\n\nLike compute(metric::ComponentTimedMetric, results::IS.Results, selector::ComponentSelector; kwargs...) but for Components rather than ComponentSelectors, used in the implementation of that method. Compute the given metric on the given component within the given set of results, returning a DataFrame with a DateTime column and a data column labeled with the component's name.\n\nArguments\n\nmetric::ComponentTimedMetric: the metric to compute\nresults::IS.Results: the results from which to fetch data\ncomp::Component: the component on which to compute the metric\nstart_time::Union{Nothing, DateTime} = nothing: the time at which the resulting time series should begin\nlen::Union{Int, Nothing} = nothing: the number of steps in the resulting time series\n\nSee also: compute unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.compute-Tuple{CustomTimedMetric, InfrastructureSystems.Results, Union{ComponentSelector, Component}}","page":"Public API","title":"PowerAnalytics.compute","text":"compute(\n    metric::CustomTimedMetric,\n    results::InfrastructureSystems.Results,\n    comp::Union{ComponentSelector, Component};\n    kwargs...\n) -> Any\n\n\ncompute method for CustomTimedMetric. Compute the given metric on the given component within the given set of results, returning a DataFrame with a DateTime column and a data column labeled with the component's name. Exclude components marked as not available.\n\nArguments\n\nmetric::CustomTimedMetric: the metric to compute\nresults::IS.Results: the results from which to fetch data\ncomp::Component: the component on which to compute the metric\nstart_time::Union{Nothing, DateTime} = nothing: the time at which the resulting time series should begin\nlen::Union{Int, Nothing} = nothing: the number of steps in the resulting time series\n\nSee also: compute unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.compute-Tuple{ResultsTimelessMetric, InfrastructureSystems.Results, Nothing}","page":"Public API","title":"PowerAnalytics.compute","text":"compute(\n    metric::ResultsTimelessMetric,\n    results::InfrastructureSystems.Results,\n    selector::Nothing\n) -> DataFrames.DataFrame\n\n\nConvenience method that ignores the selector argument and redirects to compute(metric::ResultsTimelessMetric, results::IS.Results; kwargs...) for the purposes of compute_all.\n\nSee also: compute unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.compute-Tuple{ResultsTimelessMetric, InfrastructureSystems.Results}","page":"Public API","title":"PowerAnalytics.compute","text":"compute(\n    metric::ResultsTimelessMetric,\n    results::InfrastructureSystems.Results\n) -> DataFrames.DataFrame\n\n\ncompute method for ResultsTimelessMetric. Compute the given metric on the given set of results, returning a DataFrame with a single cell. Exclude components marked as not available.\n\nArguments\n\nmetric::ResultsTimelessMetric: the metric to compute\nresults::IS.Results: the results from which to fetch data\n\nSee also: compute unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.compute-Tuple{SystemTimedMetric, InfrastructureSystems.Results, Nothing}","page":"Public API","title":"PowerAnalytics.compute","text":"compute(\n    metric::SystemTimedMetric,\n    results::InfrastructureSystems.Results,\n    selector::Nothing;\n    kwargs...\n) -> Any\n\n\nConvenience method that ignores the selector argument and redirects to compute(metric::SystemTimedMetric, results::IS.Results; kwargs...) for the purposes of compute_all.\n\nSee also: compute unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.compute-Tuple{SystemTimedMetric, InfrastructureSystems.Results}","page":"Public API","title":"PowerAnalytics.compute","text":"compute(\n    metric::SystemTimedMetric,\n    results::InfrastructureSystems.Results;\n    kwargs...\n) -> Any\n\n\ncompute method for SystemTimedMetric. Compute the given metric on the System associated with the given set of results, returning a DataFrame with a DateTime column and a data column.\n\nArguments\n\nmetric::SystemTimedMetric: the metric to compute\nresults::IS.Results: the results from which to fetch data\nstart_time::Union{Nothing, DateTime} = nothing: the time at which the resulting time series should begin\nlen::Union{Int, Nothing} = nothing: the number of steps in the resulting time series\n\nSee also: compute unified function documentation\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#Miscellaneous","page":"Public API","title":"Miscellaneous","text":"","category":"section"},{"location":"reference/public/#PowerAnalytics.unweighted_sum","page":"Public API","title":"PowerAnalytics.unweighted_sum","text":"unweighted_sum(x) -> Any\n\n\nA version of sum that ignores a second argument, for use where aggregation metadata is at play.\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.weighted_mean","page":"Public API","title":"PowerAnalytics.weighted_mean","text":"weighted_mean(vals, weights) -> Any\n\n\nCompute the mean of values weighted by the corresponding entries of weights. Arguments may be vectors or vectors of vectors. A weight of 0 cancels out a value of NaN.\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.metric_selector_to_string","page":"Public API","title":"PowerAnalytics.metric_selector_to_string","text":"metric_selector_to_string(\n    m::Metric,\n    e::Union{ComponentSelector, Component}\n) -> Any\n\n\nCanonical way to represent a (Metric, ComponentSelector) or (Metric, Component) pair as a string.\n\n\n\n\n\n","category":"function"},{"location":"reference/public/#PowerAnalytics.AGG_META_KEY","page":"Public API","title":"PowerAnalytics.AGG_META_KEY","text":"Column metadata key whose value, if any, is additional information to be passed to aggregation functions. Values of nothing are equivalent to absence of the entry.\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.DATETIME_COL","page":"Public API","title":"PowerAnalytics.DATETIME_COL","text":"Name of the column that represents the time axis in computed DataFrames. Currently equal to \"DateTime\".\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.META_COL_KEY","page":"Public API","title":"PowerAnalytics.META_COL_KEY","text":"Column metadata key whose value signifies whether the column is metadata. Metadata columns are excluded from get_data_cols and similar and can be used to represent things like a time aggregation.\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.RESULTS_COL","page":"Public API","title":"PowerAnalytics.RESULTS_COL","text":"Name of a column that represents whole-of-Results data. Currently equal to \"Results\".\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#PowerAnalytics.SYSTEM_COL","page":"Public API","title":"PowerAnalytics.SYSTEM_COL","text":"Name of a column that represents whole-of-System data. Currently equal to \"System\".\n\n\n\n\n\n","category":"constant"},{"location":"reference/public/#Old-PowerAnalytics","page":"Public API","title":"Old PowerAnalytics","text":"","category":"section"},{"location":"reference/public/","page":"Public API","title":"Public API","text":"This interface predates the 1.0 version and will eventually be deprecated.","category":"page"},{"location":"reference/public/#PowerAnalytics.categorize_data-Tuple{Dict{Symbol, DataFrames.DataFrame}, Dict}","page":"Public API","title":"PowerAnalytics.categorize_data","text":"categorize_data(\n    data::Dict{Symbol, DataFrames.DataFrame},\n    aggregation::Dict;\n    curtailment,\n    slacks\n) -> Dict{String, DataFrames.DataFrame}\n\n\nRe-categorizes data according to an aggregation dictionary\n\nmakes no guarantee of complete data collection *\n\nExample\n\naggregation = PA.make_fuel_dictionary(results_uc.system)\ncategorize_data(gen_uc.data, aggregation)\n\n\n\n\n\n","category":"method"},{"location":"reference/public/#PowerAnalytics.make_fuel_dictionary-Tuple{System, Dict{NamedTuple, String}}","page":"Public API","title":"PowerAnalytics.make_fuel_dictionary","text":"make_fuel_dictionary(\n    sys::System,\n    mapping::Dict{NamedTuple, String};\n    filter_func,\n    kwargs...\n) -> Dict{Any, Any}\n\n\ngenerators = make_fuel_dictionary(system::PSY.System, mapping::Dict{NamedTuple, String})\n\nThis function makes a dictionary of fuel type and the generators associated.\n\nArguments\n\nsys::PSY.System: the system that is used to create the results\nresults::IS.Results: results\n\nKeyword Arguments\n\ncategories::Dict{String, NamedTuple}: if stacking by a different category is desired\n\nExamples\n\nresults = solve_op_model!(OpModel)\ngenerators = make_fuel_dictionary(sys)\n\n\n\n\n\n","category":"method"},{"location":"how_to_guides/stub/#How-to-Guides","page":"-","title":"How-to Guides","text":"","category":"section"},{"location":"how_to_guides/stub/","page":"-","title":"-","text":"How-tos can be be referenced when looking for guidance for specific scenarios and issues in PowerAnalytics. These are still under construction, check for more here soon!","category":"page"},{"location":"explanation/stub/#Explanation","page":"-","title":"Explanation","text":"","category":"section"},{"location":"explanation/stub/","page":"-","title":"-","text":"Refer here to find context and further explanation of the workings of PowerAnalytics. This is still under construction, check for more here soon!","category":"page"},{"location":"reference/developer_guidelines/#Developer-Guidelines","page":"Developer Guidelines","title":"Developer Guidelines","text":"","category":"section"},{"location":"reference/developer_guidelines/","page":"Developer Guidelines","title":"Developer Guidelines","text":"In order to contribute to PowerAnalytics.jl repository please read the following sections of InfrastructureSystems.jl and SiennaTemplate.jl documentation in detail:","category":"page"},{"location":"reference/developer_guidelines/","page":"Developer Guidelines","title":"Developer Guidelines","text":"Style Guide\nDocumentation Best Practices\nContributing Guidelines","category":"page"},{"location":"reference/developer_guidelines/","page":"Developer Guidelines","title":"Developer Guidelines","text":"Pull requests are always welcome to fix bugs or add additional modeling capabilities.","category":"page"},{"location":"reference/developer_guidelines/","page":"Developer Guidelines","title":"Developer Guidelines","text":"All the code contributions need to include tests with a minimum coverage of 70%.","category":"page"},{"location":"#PowerAnalytics.jl","page":"Welcome Page","title":"PowerAnalytics.jl","text":"","category":"section"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerAnalytics.jl is a Julia package designed to support power system simulation results analysis. It relies on results generated from PowerSimulations.jl and data structures defined in PowerSystems.jl. PowerAnalytics also provides the data collection, aggregation, and subsetting for PowerGraphics.jl.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The tutorial, how-to, and explanation sections of the documentation are still under construction; the most informative section is the public API reference. PowerAnalytics depends heavily on the ComponentSelector feature of PowerSystems.jl, documented here.","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerAnalytics can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerAnalytics","category":"page"},{"location":"#About-Sienna","page":"Welcome Page","title":"About Sienna","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerAnalytics.jl is part of the National Renewable Energy Laboratory's Sienna ecosystem, an open source framework for power system modeling, simulation, and optimization. The Sienna ecosystem can be found on GitHub. It contains three applications:","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Sienna\\Data enables efficient data input, analysis, and transformation\nSienna\\Ops enables enables system scheduling simulations by formulating and solving optimization problems\nSienna\\Dyn enables system transient analysis including small signal stability and full system dynamic simulations","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Each application uses multiple packages written in the Julia programming language.","category":"page"},{"location":"reference/internal/#Internal","page":"Internals","title":"Internal","text":"","category":"section"},{"location":"reference/internal/#PowerAnalytics.EntryType","page":"Internals","title":"PowerAnalytics.EntryType","text":"The various key entry types that can be used to make a PSI.OptimizationContainerKey\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#PowerAnalytics.SystemEntryType","page":"Internals","title":"PowerAnalytics.SystemEntryType","text":"The various key entry types that can work with a System\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#PowerAnalytics.NoResultError","page":"Internals","title":"PowerAnalytics.NoResultError","text":"PowerAnalytics.NoResultError(msg::AbstractString)\n\nSignifies that the metric does not have a result for the Component/ComponentSelector/etc. on which it is being called.\n\n\n\n\n\n","category":"type"},{"location":"reference/internal/#PowerAnalytics.combine_categories-Tuple{Union{Dict{String, DataFrames.DataFrame}, Dict{Symbol, DataFrames.DataFrame}}}","page":"Internals","title":"PowerAnalytics.combine_categories","text":"combine_categories(\n    data::Union{Dict{String, DataFrames.DataFrame}, Dict{Symbol, DataFrames.DataFrame}};\n    names,\n    aggregate\n) -> Any\n\n\naggregates and combines data into single DataFrame\n\nExample\n\nPG.combine_categories(gen_uc.data)\n\n\n\n\n\n","category":"method"},{"location":"reference/internal/#PowerAnalytics.get_generator_category-Tuple{Any, Any, Any, Any, Dict{NamedTuple, String}}","page":"Internals","title":"PowerAnalytics.get_generator_category","text":"get_generator_category(\n    gentype,\n    fuel,\n    primemover,\n    ext,\n    mappings::Dict{NamedTuple, String}\n) -> Union{Nothing, String}\n\n\nReturn the generator category for this fuel and unit_type.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal/#PowerAnalytics.get_generator_mapping","page":"Internals","title":"PowerAnalytics.get_generator_mapping","text":"get_generator_mapping() -> Dict{NamedTuple, String}\nget_generator_mapping(filename) -> Dict{NamedTuple, String}\n\n\nReturn a dict where keys are a tuple of input parameters (fuel, unit_type) and values are generator types.\n\n\n\n\n\n","category":"function"},{"location":"reference/internal/#PowerAnalytics.lookup_gentype-Tuple{AbstractString}","page":"Internals","title":"PowerAnalytics.lookup_gentype","text":"lookup_gentype(gentype::AbstractString) -> Any\n\n\nParse the gentype to a type. This is done by first checking whether gentype is qualified (ModuleName.TypeName). If so, the module is fetched from the Main scope and the type name is fetched from the module. If not, we default to fetching from PowerSystems for convenience.\n\n\n\n\n\n","category":"method"},{"location":"reference/internal/#PowerAnalytics.make_component_metric_from_entry-Tuple{String, Type{<:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}}","page":"Internals","title":"PowerAnalytics.make_component_metric_from_entry","text":"make_component_metric_from_entry(\n    name::String,\n    key::Type{<:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}\n) -> ComponentTimedMetric\n\n\nConvenience function to convert an EntryType to a function and make a ComponentTimedMetric from it\n\n\n\n\n\n","category":"method"},{"location":"reference/internal/#PowerAnalytics.make_entry_kwargs-Tuple{Vector{<:Tuple}}","page":"Internals","title":"PowerAnalytics.make_entry_kwargs","text":"make_entry_kwargs(key_tuples::Vector{<:Tuple}) -> Vector\n\n\nSort a vector of key tuples into variables, parameters, etc. like PSI.load_results! wants\n\n\n\n\n\n","category":"method"},{"location":"reference/internal/#PowerAnalytics.make_key","page":"Internals","title":"PowerAnalytics.make_key","text":"Create a PSI.OptimizationContainerKey from the given key entry type and component.\n\nArguments\n\nentry::Type{<:EntryType}: the key entry\ncomponent (::Type{<:Union{Component, PSY.System}} or ::Type{<:Component} depending on the key type): the component type\n\n\n\n\n\n","category":"function"},{"location":"reference/internal/#PowerAnalytics.make_system_metric_from_entry-Tuple{String, Type{<:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}}","page":"Internals","title":"PowerAnalytics.make_system_metric_from_entry","text":"make_system_metric_from_entry(\n    name::String,\n    key::Type{<:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}\n) -> SystemTimedMetric\n\n\nConvenience function to convert a SystemEntryType to a function and make a SystemTimedMetric from it\n\n\n\n\n\n","category":"method"},{"location":"reference/internal/#PowerAnalytics.read_component_result-Tuple{InfrastructureSystems.Results, Type{<:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}, Component}","page":"Internals","title":"PowerAnalytics.read_component_result","text":"read_component_result(\n    res::InfrastructureSystems.Results,\n    entry::Type{<:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}},\n    comp::Component;\n    start_time,\n    len\n) -> Any\n\n\nGiven an EntryType and a Component, fetch a single column of results\n\n\n\n\n\n","category":"method"},{"location":"reference/internal/#PowerAnalytics.read_system_result-Tuple{InfrastructureSystems.Results, Type{<:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}}","page":"Internals","title":"PowerAnalytics.read_system_result","text":"read_system_result(\n    res::InfrastructureSystems.Results,\n    entry::Type{<:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}};\n    start_time,\n    len\n) -> Any\n\n\nGiven an EntryType that applies to the System, fetch a single column of results\n\n\n\n\n\n","category":"method"},{"location":"reference/internal/#PowerAnalytics.Metrics.make_calc_is_slack_up-Tuple{Real}","page":"Internals","title":"PowerAnalytics.Metrics.make_calc_is_slack_up","text":"Create a boolean Metric for whether the given time period has system balance slack up of magnitude greater than the threshold argument\n\n\n\n\n\n","category":"method"}]
}
