<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulation Scenarios Analysis · PowerAnalytics.jl</title><meta name="title" content="Simulation Scenarios Analysis · PowerAnalytics.jl"/><meta property="og:title" content="Simulation Scenarios Analysis · PowerAnalytics.jl"/><meta property="twitter:title" content="Simulation Scenarios Analysis · PowerAnalytics.jl"/><meta name="description" content="Documentation for PowerAnalytics.jl."/><meta property="og:description" content="Documentation for PowerAnalytics.jl."/><meta property="twitter:description" content="Documentation for PowerAnalytics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerAnalytics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerAnalytics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Simulation Scenarios Analysis</a><ul class="internal"><li><a class="tocitem" href="#System"><span>System</span></a></li><li><a class="tocitem" href="#Simulation-Scenarios"><span>Simulation Scenarios</span></a></li><li><a class="tocitem" href="#Loading-Simulation-Scenario-Results"><span>Loading Simulation Scenario Results</span></a></li><li><a class="tocitem" href="#Single-Scenario-Results"><span>Single Scenario Results</span></a></li><li><a class="tocitem" href="#Multiple-Scenarios-Results"><span>Multiple Scenarios Results</span></a></li></ul></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/public/">Public API</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/developer_guidelines/">Developer Guidelines</a></li><li><a class="tocitem" href="../../reference/internal/">Internals</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Simulation Scenarios Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulation Scenarios Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerAnalytics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/main/docs/src/tutorials/PA_workflow_tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Scenarios_PA_tutorial"><a class="docs-heading-anchor" href="#Scenarios_PA_tutorial">Simulation Scenarios Analysis</a><a id="Scenarios_PA_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Scenarios_PA_tutorial" title="Permalink"></a></h1><h2 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h2><p>In this tutorial, we postprocess the simulation results of the Reliability Test System Grid Modernization Lab Consortium (<a href="https://github.com/GridMod/RTS-GMLC">RTS-GMLC</a>) system (<a href="https://doi.org/10.1109/TPWRS.2019.2925557">DOI: 10.1109/TPWRS.2019.2925557</a>), which is an updated version of the <a href="https://ieeexplore.ieee.org/document/780914?arnumber=780914&amp;tag=1">RTS-96</a> with an artificial location situated on an area that covers parts of California, Nevada and Arizona in the southwestern United States. </p><p>The RTS-GMLC test system consists of: </p><ul><li>73 buses, </li><li>105 transmission lines, </li><li>157 generators (including 57 solar PV facilities, 4 wind turbines, 20 hydro units and 1 concentrated solar plant), </li><li>1 short-duration (3 hours) storage device with 100 % charging and discharging efficiency</li></ul><p align="center">
  <img src="../../assets/nodemap_RTSGMLC.png" width="700">
  <br>
  <b>Fig. 1 - <a href="https://github.com/GridMod/RTS-GMLC/blob/master/node_re_basemap.png">RTS-GMLC system</a></b>
</p><h2 id="Simulation-Scenarios"><a class="docs-heading-anchor" href="#Simulation-Scenarios">Simulation Scenarios</a><a id="Simulation-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Scenarios" title="Permalink"></a></h2><p>We have obtained simulation results for the following two simulation scenarios: </p><ul><li><p><strong>Scenario 1</strong> : simulation using the RTS-GMLC test system without any additional modifications (baseline scenario) </p></li><li><p><strong>Scenario 2</strong> : simulation using the RTS-GMLC test system with increased energy and power capacity of the storage device </p></li></ul><p>The simulations were performed using the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/">PowerSystems.jl</a> and <a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/">PowerSimulations.jl</a> packages of Sienna. The <a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/Network/#CopperPlatePowerModel"><code>CopperPlatePowerModel</code></a> formulation was considered for the <a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/Network/#PowerSimulations.NetworkModel"><code>NetworkModel</code></a>, while the formulations chosen for each of the component types we want to include in the simulation are presented in the table below: </p><table><tr><th style="text-align: right">Component Type</th><th style="text-align: right">Formulation</th></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Line/#Line"><code>Line</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/Branch/#StaticBranch"><code>StaticBranch</code></a></td></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_TapTransformer/#TapTransformer"><code>TapTransformer</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/Branch/#StaticBranch"><code>StaticBranch</code></a></td></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_ThermalStandard/#ThermalStandard"><code>ThermalStandard</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/ThermalGen/#ThermalBasicUnitCommitment"><code>ThermalBasicUnitCommitment</code></a></td></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_RenewableDispatch/#RenewableDispatch"><code>RenewableDispatch</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/RenewableGen/#RenewableFullDispatch"><code>RenewableFullDispatch</code></a></td></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_RenewableNonDispatch/#RenewableNonDispatch"><code>RenewableNonDispatch</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/General/#FixedOutput"><code>FixedOutput</code></a></td></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_HydroDispatch/#HydroDispatch"><code>HydroDispatch</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/HydroPowerSimulations.jl/dev/formulation/#HydroDispatchRunOfRiver"><code>HydroDispatchRunOfRiver</code></a></td></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_HydroEnergyReservoir/#HydroEnergyReservoir"><code>HydroEnergyReservoir</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/HydroPowerSimulations.jl/dev/formulation/#HydroDispatchRunOfRiver"><code>HydroDispatchRunOfRiver</code></a></td></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_EnergyReservoirStorage/#EnergyReservoirStorage"><code>EnergyReservoirStorage</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/StorageSystemsSimulations.jl/stable/formulation_library/StorageDispatchWithReserves/#StorageSystemsSimulations.StorageDispatchWithReserves"><code>StorageDispatchWithReserves</code></a></td></tr><tr><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_PowerLoad/#PowerLoad"><code>PowerLoad</code></a></td><td style="text-align: right"><a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/Load/#StaticPowerLoad"><code>StaticPowerLoad</code></a></td></tr></table><div class="admonition is-info" id="Info-eed8ab28e0aa157f"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-eed8ab28e0aa157f" title="Permalink"></a></header><div class="admonition-body"><p>More information regarding the different formulations can be found in the <a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/formulation_library/Introduction/"><code>PowerSimulations.jl</code> Formulation Library</a>.</p></div></div><p>We document the above here for completeness, since those will directly define the structure of the optimization problem and consequently its auxiliary variables, expressions, parameters and variables for which realized result values are available. </p><p>The script that was used to configure and execute the simulation scenarios referenced above can be found <a href="https://github.com/NREL-Sienna/PowerAnalytics.jl/tree/main/docs/src/tutorials/_run_scenarios_RTS_Tutorial.jl">here</a></p><h2 id="Loading-Simulation-Scenario-Results"><a class="docs-heading-anchor" href="#Loading-Simulation-Scenario-Results">Loading Simulation Scenario Results</a><a id="Loading-Simulation-Scenario-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-Simulation-Scenario-Results" title="Permalink"></a></h2><p>We begin by loading all the necessary Julia packages.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using PowerSystems</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using PowerSimulations</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StorageSystemsSimulations</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using HydroPowerSimulations</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DataFrames</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Dates</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using CSV</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Plots</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using PowerAnalytics</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const PA = PowerAnalytics</code><code class="nohighlight hljs ansi" style="display:block;">PowerAnalytics</code></pre><p>To begin our analysis, we first specify the directory where the simulation results are stored. In our case, the results of both simulation scenarios have been saved within the same directory. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; results_dir = &quot;_simulation_results_RTS&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;_simulation_results_RTS&quot;</code></pre><p>Once we have defined the directory containing our simulation results, the next step is to load them into a structured format for our analysis. </p><p><a href="../../reference/public/#PowerAnalytics.create_problem_results_dict"><code>create_problem_results_dict</code></a> facilitates this by constructing a dictionary where each key corresponds to a scenario name.</p><p>We also specify <code>&quot;UC&quot;</code>, which corresponds to the name we assigned when creating the <a href="https://nrel-sienna.github.io/PowerSimulations.jl/stable/tutorials/decision_problem/#DecisionModel"><code>DecisionModel</code></a> and refers to the results of the unit commitment simulation. The <code>populate_system=true</code> argument ensures that the system model is attached to the results.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; results_all = create_problem_results_dict(results_dir, &quot;UC&quot;; populate_system=true)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Loading simulation results from _simulation_results_RTS/Scenario_1
<span class="sgr36"><span class="sgr1">[ Info: </span></span>checking integrity of simulation_store.h5
<span class="sgr36"><span class="sgr1">[ Info: </span></span>De-serialized the system from the simulation store. The system does not include time series data.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Unit System changed to UnitSystem.NATURAL_UNITS = 2
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Loading simulation results from _simulation_results_RTS/Scenario_2
<span class="sgr36"><span class="sgr1">[ Info: </span></span>checking integrity of simulation_store.h5
<span class="sgr36"><span class="sgr1">[ Info: </span></span>De-serialized the system from the simulation store. The system does not include time series data.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Unit System changed to UnitSystem.NATURAL_UNITS = 2
DataStructures.SortedDict{Any, Any, Base.Order.ForwardOrdering} with 2 entries:
  &quot;Scenario_1&quot; =&gt; SimulationProblemResults{DecisionModelSimulationResults}(&quot;UC&quot;…
  &quot;Scenario_2&quot; =&gt; SimulationProblemResults{DecisionModelSimulationResults}(&quot;UC&quot;…</code></pre><h2 id="Single-Scenario-Results"><a class="docs-heading-anchor" href="#Single-Scenario-Results">Single Scenario Results</a><a id="Single-Scenario-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Scenario-Results" title="Permalink"></a></h2><p>In this section of the tutorial, we focus on the results of a single simulation scenario. Since the <code>results_all</code> dictionary contains entries for multiple scenarios, we can extract the results for the first one using: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; results_uc = first(values(results_all))</code><code class="nohighlight hljs ansi" style="display:block;">Start: 2020-07-01T00:00:00
End: 2020-07-31T00:00:00
Resolution: 60 minutes

<span class="sgr1">UC Problem Auxiliary variables Results
┌─────────────────────────────────────────────┐
│ HydroEnergyOutput__HydroEnergyReservoir     │
│ StorageEnergyOutput__EnergyReservoirStorage │
│ HydroEnergyOutput__HydroDispatch            │
└─────────────────────────────────────────────┘

UC Problem Expressions Results
┌────────────────────────────────────────────────┐
│ FuelConsumptionExpression__ThermalStandard     │
│ ProductionCostExpression__RenewableDispatch    │
│ ActivePowerBalance__System                     │
│ ProductionCostExpression__HydroEnergyReservoir │
│ ProductionCostExpression__ThermalStandard      │
│ ProductionCostExpression__HydroDispatch        │
└────────────────────────────────────────────────┘

UC Problem Parameters Results
┌──────────────────────────────────────────────────────┐
│ ActivePowerTimeSeriesParameter__HydroDispatch        │
│ ActivePowerTimeSeriesParameter__RenewableNonDispatch │
│ ActivePowerTimeSeriesParameter__RenewableDispatch    │
│ ActivePowerTimeSeriesParameter__PowerLoad            │
│ ActivePowerTimeSeriesParameter__HydroEnergyReservoir │
└──────────────────────────────────────────────────────┘

UC Problem Variables Results
┌────────────────────────────────────────────────┐
│ EnergyVariable__EnergyReservoirStorage         │
│ StopVariable__ThermalStandard                  │
│ ActivePowerOutVariable__EnergyReservoirStorage │
│ StartVariable__ThermalStandard                 │
│ OnVariable__ThermalStandard                    │
│ ActivePowerVariable__HydroDispatch             │
│ ActivePowerInVariable__EnergyReservoirStorage  │
│ ActivePowerVariable__ThermalStandard           │
│ ActivePowerVariable__HydroEnergyReservoir      │
│ ActivePowerVariable__RenewableDispatch         │
└────────────────────────────────────────────────┘</span></code></pre><p>Notice that in the output, the names of the realized auxiliary variables, problem expressions, problem parameters, and problem variables available in the results are all listed.</p><h3 id="Obtain-the-generation-time-series-for-each-individual-thermal-component-of-the-system"><a class="docs-heading-anchor" href="#Obtain-the-generation-time-series-for-each-individual-thermal-component-of-the-system">Obtain the generation time series for each individual thermal component of the system</a><a id="Obtain-the-generation-time-series-for-each-individual-thermal-component-of-the-system-1"></a><a class="docs-heading-anchor-permalink" href="#Obtain-the-generation-time-series-for-each-individual-thermal-component-of-the-system" title="Permalink"></a></h3><p>After confirming that the key <code>ActivePowerVariable__ThermalStandard</code> is present among the realized variables, we can now extract the generation time series for all the thermal (<a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_ThermalStandard/#ThermalStandard"><code>ThermalStandard</code></a>) generators in our system. To achieve this, we follow two steps:</p><ul><li>Create a <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.ComponentSelector"><code>ComponentSelector</code></a> that identifies the component type we are interested in (in this case <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_ThermalStandard/#ThermalStandard"><code>ThermalStandard</code></a>). </li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; thermal_standard_selector = make_selector(ThermalStandard)</code><code class="nohighlight hljs ansi" style="display:block;">InfrastructureSystems.TypeComponentSelector(ThermalStandard, :each, &quot;ThermalStandard&quot;)</code></pre><ul><li>Calculate the active power for the corresponding generators of this type using one of <code>PowerAnalytics.jl</code> defined metrics, namely <a href="../../reference/public/#PowerAnalytics.Metrics.calc_active_power"><code>calc_active_power</code></a>, which retrieves the generation time series from the results. </li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; PA.calc_active_power(thermal_standard_selector, results_uc)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">744×77 DataFrame
 Row │ DateTime             ThermalStandard__322_CT_6  ThermalStandard__321_CC ⋯
     │<span class="sgr90"> DateTime             Float64                    Float64                 ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │ 2020-07-01T00:00:00                        0.0                    231.6 ⋯
   2 │ 2020-07-01T01:00:00                        0.0                    170.0
   3 │ 2020-07-01T02:00:00                        0.0                    170.0
   4 │ 2020-07-01T03:00:00                        0.0                    170.0
   5 │ 2020-07-01T04:00:00                        0.0                    170.0 ⋯
   6 │ 2020-07-01T05:00:00                        0.0                    170.0
   7 │ 2020-07-01T06:00:00                        0.0                    170.0
   8 │ 2020-07-01T07:00:00                        0.0                    170.0
  ⋮  │          ⋮                       ⋮                          ⋮           ⋱
 738 │ 2020-07-31T17:00:00                        0.0                    293.3 ⋯
 739 │ 2020-07-31T18:00:00                        0.0                    293.3
 740 │ 2020-07-31T19:00:00                        0.0                    355.0
 741 │ 2020-07-31T20:00:00                        0.0                    293.3
 742 │ 2020-07-31T21:00:00                        0.0                    293.3 ⋯
 743 │ 2020-07-31T22:00:00                        0.0                    251.8
 744 │ 2020-07-31T23:00:00                        0.0                    231.6
</span><span class="sgr36">                                                 75 columns and 729 rows omitted</span></span></code></pre><p>Notice that in the resulting dataframe, each column represents the time series of an individual component. This behavior follows from the default settings of <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.make_selector"><code>make_selector</code></a>, since we have not specified any additional arguments to modify the default grouping.</p><p>It is also important to keep in mind that by default, only the available components of the system will be included in the resulting dataframe.</p><div class="admonition is-info" id="Info-fd755ee7d29de9aa"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-fd755ee7d29de9aa" title="Permalink"></a></header><div class="admonition-body"><p>For a complete list of the <code>PowerAnalytics.jl</code> built-in metrics, please refer to: <a href="https://nrel-sienna.github.io/PowerAnalytics.jl/stable/reference/public/#Built-in-Metrics">PowerAnalytics Built-In Metrics</a>. </p></div></div><h3 id="Obtain-the-thermal-generation-time-series-grouped-by-prime_mover"><a class="docs-heading-anchor" href="#Obtain-the-thermal-generation-time-series-grouped-by-prime_mover">Obtain the thermal generation time series grouped by prime_mover</a><a id="Obtain-the-thermal-generation-time-series-grouped-by-prime_mover-1"></a><a class="docs-heading-anchor-permalink" href="#Obtain-the-thermal-generation-time-series-grouped-by-prime_mover" title="Permalink"></a></h3><p>In some cases, it is more insightful to aggregate generation by <code>prime_mover_type</code>, in order to better understand the relative contributions of different generation technologies across the system.</p><p>To achieve this, we modify our <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.ComponentSelector"><code>ComponentSelector</code></a> using <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.rebuild_selector-Tuple%7BInfrastructureSystems.ListComponentSelector%7D"><code>rebuild_selector</code></a>, specifying <code>groupby = get_prime_mover_type</code>. This restructures the <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.ComponentSelector"><code>ComponentSelector</code></a> so that thermal generators with the same <code>prime_mover_type</code> are grouped together.  </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; thermal_standard_selector_pm = rebuild_selector(thermal_standard_selector, groupby = get_prime_mover_type)</code><code class="nohighlight hljs ansi" style="display:block;">InfrastructureSystems.TypeComponentSelector(ThermalStandard, PowerSystems.get_prime_mover_type, &quot;ThermalStandard&quot;)</code></pre><p>Once we have this new <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.ComponentSelector"><code>ComponentSelector</code></a>, we use the same metric defined in the previous subsection to compute the aggregated generation time series for each unique <code>prime_mover_type</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; PA.calc_active_power(thermal_standard_selector_pm, results_uc)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">744×5 DataFrame
 Row │ DateTime             CT       CC        ST       OT
     │<span class="sgr90"> DateTime             Float64  Float64   Float64  Float64
─────┼──────────────────────────────────────────────────────────
   1 │ 2020-07-01T00:00:00      0.0   836.767  2360.67      0.0
   2 │ 2020-07-01T01:00:00      0.0   680.0    2011.6       0.0
   3 │ 2020-07-01T02:00:00      0.0   680.0    1598.19      0.0
   4 │ 2020-07-01T03:00:00      0.0   680.0    1351.01      0.0
   5 │ 2020-07-01T04:00:00      0.0   680.0    1324.0       0.0
   6 │ 2020-07-01T05:00:00      0.0   680.0    1322.67      0.0
   7 │ 2020-07-01T06:00:00      0.0   680.0    1324.0       0.0
   8 │ 2020-07-01T07:00:00      0.0   680.0    1324.0       0.0
  ⋮  │          ⋮              ⋮        ⋮         ⋮        ⋮
 738 │ 2020-07-31T17:00:00      0.0  2069.24   2686.0       0.0
 739 │ 2020-07-31T18:00:00      0.0  2357.66   2717.0       0.0
 740 │ 2020-07-31T19:00:00      0.0  2482.6    2717.0       0.0
 741 │ 2020-07-31T20:00:00      0.0  2156.25   2686.0       0.0
 742 │ 2020-07-31T21:00:00      0.0  1868.33   2648.52      0.0
 743 │ 2020-07-31T22:00:00      0.0  1518.55   2593.33      0.0
 744 │ 2020-07-31T23:00:00      0.0  1436.82   2360.67      0.0
</span><span class="sgr36">                                                729 rows omitted</span></span></code></pre><h3 id="Identify-the-day-of-the-week-with-the-highest-total-thermal-generation-across-the-entire-system"><a class="docs-heading-anchor" href="#Identify-the-day-of-the-week-with-the-highest-total-thermal-generation-across-the-entire-system">Identify the day of the week with the highest total thermal generation across the entire system</a><a id="Identify-the-day-of-the-week-with-the-highest-total-thermal-generation-across-the-entire-system-1"></a><a class="docs-heading-anchor-permalink" href="#Identify-the-day-of-the-week-with-the-highest-total-thermal-generation-across-the-entire-system" title="Permalink"></a></h3><p>To identify the day of the week with the highest total thermal generation across the system, we begin by creating a <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.ComponentSelector"><code>ComponentSelector</code></a> that aggregates all <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_ThermalStandard/#ThermalStandard"><code>ThermalStandard</code></a> components into a single group. </p><p>This is done by setting <code>groupby = :all</code> in <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.make_selector"><code>make_selector</code></a>, which considers all thermal generators as a unified entity and performs the desired spatial aggregation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; thermal_standard_selector_sys = make_selector(ThermalStandard; groupby=:all)</code><code class="nohighlight hljs ansi" style="display:block;">InfrastructureSystems.TypeComponentSelector(ThermalStandard, :all, &quot;ThermalStandard&quot;)</code></pre><p>We again use the built-in <a href="../../reference/public/#PowerAnalytics.Metrics.calc_active_power"><code>calc_active_power</code></a> metric in order to compute the active power time series for this aggregated group. </p><p>The resulting dataframe contains the single time series representing the total thermal generation across all thermal generators in the system.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sys_active_power = PA.calc_active_power(thermal_standard_selector_sys, results_uc)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">744×2 DataFrame
 Row │ DateTime             ThermalStandard
     │<span class="sgr90"> DateTime             Float64
─────┼──────────────────────────────────────
   1 │ 2020-07-01T00:00:00          3197.43
   2 │ 2020-07-01T01:00:00          2691.6
   3 │ 2020-07-01T02:00:00          2278.19
   4 │ 2020-07-01T03:00:00          2031.01
   5 │ 2020-07-01T04:00:00          2004.0
   6 │ 2020-07-01T05:00:00          2002.67
   7 │ 2020-07-01T06:00:00          2004.0
   8 │ 2020-07-01T07:00:00          2004.0
  ⋮  │          ⋮                  ⋮
 738 │ 2020-07-31T17:00:00          4755.24
 739 │ 2020-07-31T18:00:00          5074.66
 740 │ 2020-07-31T19:00:00          5199.6
 741 │ 2020-07-31T20:00:00          4842.25
 742 │ 2020-07-31T21:00:00          4516.85
 743 │ 2020-07-31T22:00:00          4111.89
 744 │ 2020-07-31T23:00:00          3797.48
</span><span class="sgr36">                            729 rows omitted</span></span></code></pre><p>Since our goal is to compare generation values across the days of the week, we perform a temporal aggregation using <a href="../../reference/public/#PowerAnalytics.aggregate_time"><code>aggregate_time</code></a>. By passing <code>groupby_fn = dayofweek</code> as an argument, we group the data by day of the week (where 1= Monday, 2 = Tuesday, etc.), summing the total MWh generated on each weekday across the dataset.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_day = aggregate_time(sys_active_power; groupby_fn = dayofweek, groupby_col = &quot;agg_day&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">7×3 DataFrame
 Row │ DateTime             agg_day  ThermalStandard
     │<span class="sgr90"> DateTime             Int64    Float64
─────┼───────────────────────────────────────────────
   1 │ 2020-07-06T00:00:00        1        3.59081e5
   2 │ 2020-07-07T00:00:00        2        3.43765e5
   3 │ 2020-07-01T00:00:00        3   420079.0
   4 │ 2020-07-02T00:00:00        4        4.44829e5
   5 │ 2020-07-03T00:00:00        5        4.63551e5
   6 │ 2020-07-04T00:00:00        6        3.83284e5
   7 │ 2020-07-05T00:00:00        7        3.72474e5</span></span></code></pre><h3 id="Identify-the-top-10-hours-of-the-month-with-the-highest-storage-charging-values-for-each-Area"><a class="docs-heading-anchor" href="#Identify-the-top-10-hours-of-the-month-with-the-highest-storage-charging-values-for-each-Area">Identify the top 10 hours of the month with the highest storage charging values for each Area</a><a id="Identify-the-top-10-hours-of-the-month-with-the-highest-storage-charging-values-for-each-Area-1"></a><a class="docs-heading-anchor-permalink" href="#Identify-the-top-10-hours-of-the-month-with-the-highest-storage-charging-values-for-each-Area" title="Permalink"></a></h3><p>Spatially aggregating results by <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Area/#Area"><code>Area</code></a> can reveal important spatial infromation and is frequently used for example in cases of transmission flow analysis. <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Area/#Area"><code>Area</code></a> components often represent municipalities, villages or regional balancing areas of the real power system.</p><p>In this subsection, we aim to identify the top 10 hours of the month with the highest values of storage charging for each <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Area/#Area"><code>Area</code></a> of the system.</p><p>To do this, we first define a <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.ComponentSelector"><code>ComponentSelector</code></a> for all <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_EnergyReservoirStorage/#EnergyReservoirStorage"><code>EnergyReservoirStorage</code></a> components, but instead of grouping them individually, we group them by the name of the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Area/#Area"><code>Area</code></a> to which their bus belongs. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; storage_area_selector = make_selector(EnergyReservoirStorage; groupby = (x -&gt; get_name(get_area(get_bus(x)))))</code><code class="nohighlight hljs ansi" style="display:block;">InfrastructureSystems.TypeComponentSelector(EnergyReservoirStorage, Main.var&quot;#1#2&quot;(), &quot;EnergyReservoirStorage&quot;)</code></pre><p>Next, using the <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.ComponentSelector"><code>ComponentSelector</code></a> we created, we compute the total active power flowing into the storage components of each <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Area/#Area"><code>Area</code></a> using <a href="../../reference/public/#PowerAnalytics.Metrics.calc_active_power_in"><code>calc_active_power_in</code></a>, which is another one of <code>PowerAnalytics.jl</code> built-in metrics.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; df_charging = PA.calc_active_power_in(storage_area_selector, results_uc)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">744×2 DataFrame
 Row │ DateTime             3
     │<span class="sgr90"> DateTime             Float64
─────┼─────────────────────────────────
   1 │ 2020-07-01T00:00:00    0.0
   2 │ 2020-07-01T01:00:00    0.0
   3 │ 2020-07-01T02:00:00    0.0
   4 │ 2020-07-01T03:00:00   48.4412
   5 │ 2020-07-01T04:00:00    0.0
   6 │ 2020-07-01T05:00:00   49.4862
   7 │ 2020-07-01T06:00:00  100.0
   8 │ 2020-07-01T07:00:00    0.513836
  ⋮  │          ⋮               ⋮
 738 │ 2020-07-31T17:00:00    0.0
 739 │ 2020-07-31T18:00:00    0.0
 740 │ 2020-07-31T19:00:00    0.0
 741 │ 2020-07-31T20:00:00    0.0
 742 │ 2020-07-31T21:00:00    0.0
 743 │ 2020-07-31T22:00:00    0.0
 744 │ 2020-07-31T23:00:00    0.0
</span><span class="sgr36">                       729 rows omitted</span></span></code></pre><p>We observe that the resulting dataframe has only a single column for Area &quot;3&quot;. This is due to the fact that the RTS-GMLC test system contains only a single storage component, which is located in Area &quot;3&quot;. </p><p>We then iterate through each <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Area/#Area"><code>Area</code></a>, sort its time series in descending order and extract the 10 timestamps with the highest charging values, an approach that is frequently used for storage capacity value calculations.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; area_columns = names(df_charging, Not(&quot;DateTime&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;3&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for col in area_columns
           top_10_df = sort(df_charging[:, [&quot;DateTime&quot;, col]], col, rev=true)[1:10, :]
       
           println(&quot;The top 10 hours of the month for Area $col are:&quot;)
           println(top_10_df)
           println()
       end</code><code class="nohighlight hljs ansi" style="display:block;">The top 10 hours of the month for Area 3 are:
<span class="sgr1">10×2 DataFrame
 Row │ DateTime             3
     │<span class="sgr90"> DateTime             Float64
─────┼──────────────────────────────
   1 │ 2020-07-01T06:00:00    100.0
   2 │ 2020-07-02T04:00:00    100.0
   3 │ 2020-07-04T07:00:00    100.0
   4 │ 2020-07-06T07:00:00    100.0
   5 │ 2020-07-07T07:00:00    100.0
   6 │ 2020-07-08T02:00:00    100.0
   7 │ 2020-07-10T02:00:00    100.0
   8 │ 2020-07-10T06:00:00    100.0
   9 │ 2020-07-12T07:00:00    100.0
  10 │ 2020-07-14T06:00:00    100.0</span></span></code></pre><h3 id="Computing-multiple-metrics-at-once"><a class="docs-heading-anchor" href="#Computing-multiple-metrics-at-once">Computing multiple metrics at once</a><a id="Computing-multiple-metrics-at-once-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-multiple-metrics-at-once" title="Permalink"></a></h3><p>We can efficiently compute multiple metrics and add their time series in the same summary table by using the <a href="../../reference/public/#PowerAnalytics.compute_all"><code>compute_all</code></a> function. In this case, we are interested in the three most common storage built-in metrics: </p><ul><li><a href="../../reference/public/#PowerAnalytics.Metrics.calc_active_power_in"><code>calc_active_power_in</code></a>: charging power into the storage device</li><li><a href="../../reference/public/#PowerAnalytics.Metrics.calc_active_power_out"><code>calc_active_power_in</code></a>: active power output of the storage device</li><li><a href="../../reference/public/#PowerAnalytics.Metrics.calc_stored_energy"><code>calc_active_power_in</code></a>: amount of energy stored </li></ul><p>We can reuse the <code>storage_area_selector</code> defined in the previous subsection to perform spatial aggregation by <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Area/#Area"><code>Area</code></a>. However, since the resulting summary table will contain a single column for each of the three metrics, we need to adjust the selector’s grouping using <a href="https://nrel-sienna.github.io/InfrastructureSystems.jl/stable/InfrastructureSystems/#InfrastructureSystems.rebuild_selector-Tuple%7BInfrastructureSystems.ListComponentSelector%7D"><code>rebuild_selector</code></a> to aggregate the time series across all storage components in the system, rather than by <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_Area/#Area"><code>Area</code></a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; compute_all(results_uc,
           [PA.calc_active_power_in, PA.calc_active_power_out, PA.calc_stored_energy],
           [rebuild_selector(storage_area_selector, groupby = :all), rebuild_selector(storage_area_selector, groupby = :all), rebuild_selector(storage_area_selector, groupby = :all)],
           [&quot;Storage Charging&quot;, &quot;Storage Discharging&quot;, &quot;Stored Energy&quot;])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">744×4 DataFrame
 Row │ DateTime             Storage Charging  Storage Discharging  Stored Ener ⋯
     │<span class="sgr90"> DateTime             Float64           Float64              Float64     ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │ 2020-07-01T00:00:00          0.0                    0.0            0.0  ⋯
   2 │ 2020-07-01T01:00:00          0.0                    0.0            0.0
   3 │ 2020-07-01T02:00:00          0.0                    0.0            0.0
   4 │ 2020-07-01T03:00:00         48.4412                 0.0           48.44
   5 │ 2020-07-01T04:00:00          0.0                   48.4412         0.0  ⋯
   6 │ 2020-07-01T05:00:00         49.4862                 0.0           49.48
   7 │ 2020-07-01T06:00:00        100.0                    0.0          149.48
   8 │ 2020-07-01T07:00:00          0.513836               0.0          150.0
  ⋮  │          ⋮                  ⋮                   ⋮                 ⋮     ⋱
 738 │ 2020-07-31T17:00:00          0.0                    0.0          150.0  ⋯
 739 │ 2020-07-31T18:00:00          0.0                   50.0          100.0
 740 │ 2020-07-31T19:00:00          0.0                   50.0           50.0
 741 │ 2020-07-31T20:00:00          0.0                   50.0            0.0
 742 │ 2020-07-31T21:00:00          0.0                    0.0            0.0  ⋯
 743 │ 2020-07-31T22:00:00          0.0                    0.0            0.0
 744 │ 2020-07-31T23:00:00          0.0                    0.0            0.0
</span><span class="sgr36">                                                   1 column and 729 rows omitted</span></span></code></pre><h2 id="Multiple-Scenarios-Results"><a class="docs-heading-anchor" href="#Multiple-Scenarios-Results">Multiple Scenarios Results</a><a id="Multiple-Scenarios-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Scenarios-Results" title="Permalink"></a></h2><p>In this section, instead of focusing on a single simulation scenario, we compare results across multiple scenarios. This allows us to explore how changing system component parameters can influence the simulation results. </p><p>We begin by creating two new selectors, which aggregate the results for all <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_RenewableDispatch/#RenewableDispatch"><code>RenewableDispatch</code></a> and <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/model_library/generated_EnergyReservoirStorage/#EnergyReservoirStorage"><code>EnergyReservoirStorage</code></a> components respectively.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; renewable_dispatch_selector_sys = make_selector(RenewableDispatch; groupby=:all)</code><code class="nohighlight hljs ansi" style="display:block;">InfrastructureSystems.TypeComponentSelector(RenewableDispatch, :all, &quot;RenewableDispatch&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; storage_selector_sys = make_selector(EnergyReservoirStorage; groupby=:all)</code><code class="nohighlight hljs ansi" style="display:block;">InfrastructureSystems.TypeComponentSelector(EnergyReservoirStorage, :all, &quot;EnergyReservoirStorage&quot;)</code></pre><p>Next, we list all the built-in metrics we have previously used in the single simulation results analysis section to be computed for each timestep. These are: </p><ul><li><a href="../../reference/public/#PowerAnalytics.Metrics.calc_active_power"><code>calc_active_power</code></a></li><li><a href="../../reference/public/#PowerAnalytics.Metrics.calc_curtailment"><code>calc_curtailment</code></a></li><li><a href="../../reference/public/#PowerAnalytics.Metrics.calc_active_power_in"><code>calc_active_power_in</code></a></li><li><a href="../../reference/public/#PowerAnalytics.Metrics.calc_active_power_out"><code>calc_active_power_out</code></a></li><li><a href="../../reference/public/#PowerAnalytics.Metrics.calc_stored_energy"><code>calc_stored_energy</code></a></li></ul><p>We use the selectors <code>thermal_standard_selector_sys</code>, <code>renewable_dispatch_selector_sys</code> and <code>storage_selector_sys</code> to compute the active power of the thermal generators, the total curtailment of the renewable generators and the three storage specific metrics.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; time_computations = [
           (PA.calc_active_power, thermal_standard_selector_sys, &quot;Thermal Generation (MWh)&quot;),
           (PA.calc_curtailment, renewable_dispatch_selector_sys, &quot;Renewables Curtailment (MWh)&quot;),
           (PA.calc_active_power_in, storage_selector_sys, &quot;Storage Charging (MWh)&quot;),
           (PA.calc_active_power_out, storage_selector_sys, &quot;Storage Discharging (MWh)&quot;),
           (PA.calc_stored_energy, storage_selector_sys, &quot;Storage SOC (MWh)&quot;),
       ]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Tuple{ComponentSelectorTimedMetric, InfrastructureSystems.TypeComponentSelector, String}}:
 (ComponentTimedMetric(&quot;ActivePower&quot;, PowerAnalytics.var&quot;#139#141&quot;{PowerAnalytics.var&quot;#139#140#142&quot;{DataType}}(PowerAnalytics.var&quot;#139#140#142&quot;{DataType}(ActivePowerVariable)), sum, sum, sum, sum, nothing), InfrastructureSystems.TypeComponentSelector(ThermalStandard, :all, &quot;ThermalStandard&quot;), &quot;Thermal Generation (MWh)&quot;)
 (CustomTimedMetric(&quot;Curtailment&quot;, PowerAnalytics.var&quot;#113#115&quot;{PowerAnalytics.var&quot;#113#114#116&quot;{typeof(-), Tuple{ComponentTimedMetric, ComponentTimedMetric}}}(PowerAnalytics.var&quot;#113#114#116&quot;{typeof(-), Tuple{ComponentTimedMetric, ComponentTimedMetric}}(-, (ComponentTimedMetric(&quot;ActivePowerForecast&quot;, PowerAnalytics.var&quot;#139#141&quot;{PowerAnalytics.var&quot;#139#140#142&quot;{DataType}}(PowerAnalytics.var&quot;#139#140#142&quot;{DataType}(ActivePowerTimeSeriesParameter)), sum, sum, sum, sum, nothing), ComponentTimedMetric(&quot;ActivePower&quot;, PowerAnalytics.var&quot;#139#141&quot;{PowerAnalytics.var&quot;#139#140#142&quot;{DataType}}(PowerAnalytics.var&quot;#139#140#142&quot;{DataType}(ActivePowerVariable)), sum, sum, sum, sum, nothing)))), sum, sum), InfrastructureSystems.TypeComponentSelector(RenewableDispatch, :all, &quot;RenewableDispatch&quot;), &quot;Renewables Curtailment (MWh)&quot;)
 (ComponentTimedMetric(&quot;ActivePowerIn&quot;, PowerAnalytics.var&quot;#139#141&quot;{PowerAnalytics.var&quot;#139#140#142&quot;{DataType}}(PowerAnalytics.var&quot;#139#140#142&quot;{DataType}(ActivePowerInVariable)), sum, sum, sum, sum, nothing), InfrastructureSystems.TypeComponentSelector(EnergyReservoirStorage, :all, &quot;EnergyReservoirStorage&quot;), &quot;Storage Charging (MWh)&quot;)
 (ComponentTimedMetric(&quot;ActivePowerOut&quot;, PowerAnalytics.var&quot;#139#141&quot;{PowerAnalytics.var&quot;#139#140#142&quot;{DataType}}(PowerAnalytics.var&quot;#139#140#142&quot;{DataType}(ActivePowerOutVariable)), sum, sum, sum, sum, nothing), InfrastructureSystems.TypeComponentSelector(EnergyReservoirStorage, :all, &quot;EnergyReservoirStorage&quot;), &quot;Storage Discharging (MWh)&quot;)
 (ComponentTimedMetric(&quot;StoredEnergy&quot;, PowerAnalytics.var&quot;#139#141&quot;{PowerAnalytics.var&quot;#139#140#142&quot;{DataType}}(PowerAnalytics.var&quot;#139#140#142&quot;{DataType}(EnergyVariable)), sum, sum, sum, sum, nothing), InfrastructureSystems.TypeComponentSelector(EnergyReservoirStorage, :all, &quot;EnergyReservoirStorage&quot;), &quot;Storage SOC (MWh)&quot;)</code></pre><p>We are also interested in a set of metrics that are not available as time series, which we define in <code>timeless_computations</code>.  These include the: </p><ul><li>objective value </li><li>cumulative solve time </li><li>total memory allocated during the simulation</li></ul><div class="admonition is-success" id="Tip-c4aec89597914e0c"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-c4aec89597914e0c" title="Permalink"></a></header><div class="admonition-body"><p>Understanding memory usage across simulations is often particularly helpful when working with larger system models on <a href="https://nrel.github.io/HPC/">NREL&#39;s HPC systems</a>, since it can inform decisions regarding resource allocation, such as choosing between standard and high-memory partitions in order to avoid out-of-memory (OOM) errors.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; timeless_computations = [PA.calc_sum_objective_value, PA.calc_sum_solve_time, PA.calc_sum_bytes_alloc]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ResultsTimelessMetric}:
 ResultsTimelessMetric(&quot;SumObjectiveValue&quot;, PowerAnalytics.Metrics.var&quot;#36#37&quot;{String}(&quot;objective_value&quot;))
 ResultsTimelessMetric(&quot;SumSolveTime&quot;, PowerAnalytics.Metrics.var&quot;#36#37&quot;{String}(&quot;solve_time&quot;))
 ResultsTimelessMetric(&quot;SumBytesAlloc&quot;, PowerAnalytics.Metrics.var&quot;#36#37&quot;{String}(&quot;solve_bytes_alloc&quot;))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; timeless_names = [&quot;Objective Value&quot;, &quot;Solve Time (s)&quot;, &quot;Memory Allocated&quot;];</code></pre><p>Next, we define two utility functions, which form the core of our multi-scenario analysis pipeline and are executed for each individual scenario, namely:</p><ul><li><p><code>analyze_one</code>: an analytics routine, which takes in the desired time-based and timeless metrics as arguments. It computes the selected time series metrics, aggregates them over time and appends the timeless metrics into a unified summary table. </p></li><li><p><code>save_one</code>: saves the outputs from analyze_one to disk</p></li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function analyze_one(results)
           time_series_analytics = compute_all(results, time_computations...)
           aggregated_time = aggregate_time(time_series_analytics)
           computed_all = compute_all(results, timeless_computations, nothing, timeless_names)
           all_time_analytics = hcat(aggregated_time, computed_all)
           return time_series_analytics, all_time_analytics
       end</code><code class="nohighlight hljs ansi" style="display:block;">analyze_one (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function save_one(output_dir, time_series_analytics, all_time_analytics)
           CSV.write(joinpath(output_dir, &quot;summary_dataframe_new.csv&quot;), time_series_analytics)
           CSV.write(joinpath(output_dir, &quot;summary_stats_new.csv&quot;), all_time_analytics)
       end</code><code class="nohighlight hljs ansi" style="display:block;">save_one (generic function with 1 method)</code></pre><p>Finally, we define the main post-processing routine that runs across all scenarios. After processing all scenarios, it concatenates the summaries into a single dataframe, which also gets exported to a csv file. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function post_processing(all_results)
       
           summaries = []
           for (scenario_name, results) in pairs(all_results)
               println(&quot;Computing for scenario: &quot;, scenario_name)
               (time_series_analytics, all_time_analytics) = analyze_one(results)
               save_one(results.results_output_folder, time_series_analytics, all_time_analytics)
               push!(summaries, hcat(DataFrame(&quot;Scenario&quot; =&gt; scenario_name), all_time_analytics))
           end
       
           summaries_df = vcat(summaries...)
           CSV.write(&quot;all_scenarios_summary_new.csv&quot;, summaries_df)
           return summaries_df
       end</code><code class="nohighlight hljs ansi" style="display:block;">post_processing (generic function with 1 method)</code></pre><p>We run the <code>post_processing</code> routine with our multi-scenario results we previously defined. We can see the final summary table including all scenarios below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; df = post_processing(results_all);</code><code class="nohighlight hljs ansi" style="display:block;">Computing for scenario: Scenario_1
Computing for scenario: Scenario_2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; show(df; allcols=true)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">2×10 DataFrame
 Row │ Scenario    DateTime             Thermal Generation (MWh)  Renewables Curtailment (MWh)  Storage Charging (MWh)  Storage Discharging (MWh)  Storage SOC (MWh)  Objective Value  Solve Time (s)  Memory Allocated
     │<span class="sgr90"> String      DateTime             Float64                   Float64                       Float64                 Float64                    Float64            Float64          Float64         Float64
─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │ Scenario_1  2020-07-01T00:00:00                 2.78706e6                       31738.5                 7127.38                    7127.38      55657.3              1.32488e8         90.3095         1.28553e8
   2 │ Scenario_2  2020-07-01T00:00:00                 2.78266e6                       27960.7                48553.3                    48553.3           5.72827e5        1.29722e8         94.9514         6.39114e7</span></span></code></pre><p>Looking at the final dataframe, we can now easily compare the aggregated results of the selected metrics between the two simulation scenarios. </p><p>Focusing on the thermal generation and renewable curtailment results for example, we observe a decrease of approximately 0.15% in total thermal generation and approximately 11.90% in renewable curtailment across the full simulation horizon and the entire system. The increased energy capacity of the storage device in the second scenario enables it to store more excess renewable energy rather than curtail it, which in turn reduces the need for thermal generation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Welcome Page</a><a class="docs-footer-nextpage" href="../../reference/public/">Public API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Tuesday 24 June 2025 19:42">Tuesday 24 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
