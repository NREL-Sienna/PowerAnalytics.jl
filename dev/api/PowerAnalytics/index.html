<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerAnalytics · PowerAnalytics.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerAnalytics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerAnalytics.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>PowerAnalytics</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Exported"><span>Exported</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>PowerAnalytics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PowerAnalytics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/main/docs/src/api/PowerAnalytics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerAnalytics"><a class="docs-heading-anchor" href="#PowerAnalytics">PowerAnalytics</a><a id="PowerAnalytics-1"></a><a class="docs-heading-anchor-permalink" href="#PowerAnalytics" title="Permalink"></a></h1><p>API documentation</p><ul><li><a href="#PowerAnalytics">PowerAnalytics</a></li><li class="no-marker"><ul><li><a href="#Index">Index</a></li><li><a href="#Exported">Exported</a></li><li><a href="#Internal">Internal</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PowerAnalytics.AGG_META_KEY"><code>PowerAnalytics.AGG_META_KEY</code></a></li><li><a href="#PowerAnalytics.DATETIME_COL"><code>PowerAnalytics.DATETIME_COL</code></a></li><li><a href="#PowerAnalytics.META_COL_KEY"><code>PowerAnalytics.META_COL_KEY</code></a></li><li><a href="#PowerAnalytics.RESULTS_COL"><code>PowerAnalytics.RESULTS_COL</code></a></li><li><a href="#PowerAnalytics.SYSTEM_COL"><code>PowerAnalytics.SYSTEM_COL</code></a></li><li><a href="#PowerAnalytics.ComponentSelectorTimedMetric"><code>PowerAnalytics.ComponentSelectorTimedMetric</code></a></li><li><a href="#PowerAnalytics.ComponentTimedMetric"><code>PowerAnalytics.ComponentTimedMetric</code></a></li><li><a href="#PowerAnalytics.CustomTimedMetric"><code>PowerAnalytics.CustomTimedMetric</code></a></li><li><a href="#PowerAnalytics.EntryType"><code>PowerAnalytics.EntryType</code></a></li><li><a href="#PowerAnalytics.Metric"><code>PowerAnalytics.Metric</code></a></li><li><a href="#PowerAnalytics.NoResultError"><code>PowerAnalytics.NoResultError</code></a></li><li><a href="#PowerAnalytics.ResultsTimelessMetric"><code>PowerAnalytics.ResultsTimelessMetric</code></a></li><li><a href="#PowerAnalytics.SystemEntryType"><code>PowerAnalytics.SystemEntryType</code></a></li><li><a href="#PowerAnalytics.SystemTimedMetric"><code>PowerAnalytics.SystemTimedMetric</code></a></li><li><a href="#PowerAnalytics.TimedMetric"><code>PowerAnalytics.TimedMetric</code></a></li><li><a href="#PowerAnalytics.TimelessMetric"><code>PowerAnalytics.TimelessMetric</code></a></li><li><a href="#PowerAnalytics.aggregate_time-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.aggregate_time</code></a></li><li><a href="#PowerAnalytics.categorize_data-Tuple{Dict{Symbol, DataFrames.DataFrame}, Dict}"><code>PowerAnalytics.categorize_data</code></a></li><li><a href="#PowerAnalytics.combine_categories-Tuple{Union{Dict{String, DataFrames.DataFrame}, Dict{Symbol, DataFrames.DataFrame}}}"><code>PowerAnalytics.combine_categories</code></a></li><li><a href="#PowerAnalytics.compose_metrics"><code>PowerAnalytics.compose_metrics</code></a></li><li><a href="#PowerAnalytics.compute-Tuple{ResultsTimelessMetric, InfrastructureSystems.Results, Nothing}"><code>PowerAnalytics.compute</code></a></li><li><a href="#PowerAnalytics.compute-Tuple{SystemTimedMetric, InfrastructureSystems.Results, Nothing}"><code>PowerAnalytics.compute</code></a></li><li><a href="#PowerAnalytics.compute-Tuple{ResultsTimelessMetric, InfrastructureSystems.Results}"><code>PowerAnalytics.compute</code></a></li><li><a href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}"><code>PowerAnalytics.compute</code></a></li><li><a href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, PowerSystems.Component}"><code>PowerAnalytics.compute</code></a></li><li><a href="#PowerAnalytics.compute-Tuple{CustomTimedMetric, InfrastructureSystems.Results, Union{ComponentSelector, PowerSystems.Component}}"><code>PowerAnalytics.compute</code></a></li><li><a href="#PowerAnalytics.compute-Tuple{SystemTimedMetric, InfrastructureSystems.Results}"><code>PowerAnalytics.compute</code></a></li><li><a href="#PowerAnalytics.compute_all"><code>PowerAnalytics.compute_all</code></a></li><li><a href="#PowerAnalytics.compute_all-Tuple{InfrastructureSystems.Results, Vararg{Tuple{Union{TimedMetric, TimelessMetric}, Any, Any}}}"><code>PowerAnalytics.compute_all</code></a></li><li><a href="#PowerAnalytics.compute_all"><code>PowerAnalytics.compute_all</code></a></li><li><a href="#PowerAnalytics.create_problem_results_dict"><code>PowerAnalytics.create_problem_results_dict</code></a></li><li><a href="#PowerAnalytics.get_agg_meta-Tuple{Any}"><code>PowerAnalytics.get_agg_meta</code></a></li><li><a href="#PowerAnalytics.get_agg_meta-Tuple{Any, Any}"><code>PowerAnalytics.get_agg_meta</code></a></li><li><a href="#PowerAnalytics.get_data_cols-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_data_cols</code></a></li><li><a href="#PowerAnalytics.get_data_df-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_data_df</code></a></li><li><a href="#PowerAnalytics.get_data_mat-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_data_mat</code></a></li><li><a href="#PowerAnalytics.get_data_vec-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_data_vec</code></a></li><li><a href="#PowerAnalytics.get_generator_category-Tuple{Any, Any, Any, Any, Dict{NamedTuple, String}}"><code>PowerAnalytics.get_generator_category</code></a></li><li><a href="#PowerAnalytics.get_generator_mapping"><code>PowerAnalytics.get_generator_mapping</code></a></li><li><a href="#PowerAnalytics.get_time_df-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_time_df</code></a></li><li><a href="#PowerAnalytics.get_time_vec-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_time_vec</code></a></li><li><a href="#PowerAnalytics.hcat_timed_dfs-Tuple{Vararg{DataFrames.DataFrame}}"><code>PowerAnalytics.hcat_timed_dfs</code></a></li><li><a href="#PowerAnalytics.is_col_meta-Tuple{Any, Any}"><code>PowerAnalytics.is_col_meta</code></a></li><li><a href="#PowerAnalytics.lookup_gentype-Tuple{AbstractString}"><code>PowerAnalytics.lookup_gentype</code></a></li><li><a href="#PowerAnalytics.make_component_metric_from_entry-Tuple{String, Type{&lt;:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}}"><code>PowerAnalytics.make_component_metric_from_entry</code></a></li><li><a href="#PowerAnalytics.make_entry_kwargs-Tuple{Vector{&lt;:Tuple}}"><code>PowerAnalytics.make_entry_kwargs</code></a></li><li><a href="#PowerAnalytics.make_fuel_dictionary-Tuple{PowerSystems.System, Dict{NamedTuple, String}}"><code>PowerAnalytics.make_fuel_dictionary</code></a></li><li><a href="#PowerAnalytics.make_key"><code>PowerAnalytics.make_key</code></a></li><li><a href="#PowerAnalytics.make_system_metric_from_entry-Tuple{String, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}}"><code>PowerAnalytics.make_system_metric_from_entry</code></a></li><li><a href="#PowerAnalytics.metric_selector_to_string-Tuple{Metric, Union{ComponentSelector, PowerSystems.Component}}"><code>PowerAnalytics.metric_selector_to_string</code></a></li><li><a href="#PowerAnalytics.parse_generator_categories-Tuple{Any}"><code>PowerAnalytics.parse_generator_categories</code></a></li><li><a href="#PowerAnalytics.parse_generator_mapping_file-Tuple{Any}"><code>PowerAnalytics.parse_generator_mapping_file</code></a></li><li><a href="#PowerAnalytics.parse_injector_categories-Tuple{Any}"><code>PowerAnalytics.parse_injector_categories</code></a></li><li><a href="#PowerAnalytics.read_component_result-Tuple{InfrastructureSystems.Results, Type{&lt;:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}, PowerSystems.Component}"><code>PowerAnalytics.read_component_result</code></a></li><li><a href="#PowerAnalytics.read_system_result-Tuple{InfrastructureSystems.Results, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}}"><code>PowerAnalytics.read_system_result</code></a></li><li><a href="#PowerAnalytics.rebuild_metric-Tuple{T} where T&lt;:Metric"><code>PowerAnalytics.rebuild_metric</code></a></li><li><a href="#PowerAnalytics.set_agg_meta!-Tuple{Any, Any}"><code>PowerAnalytics.set_agg_meta!</code></a></li><li><a href="#PowerAnalytics.set_agg_meta!-Tuple{Any, Any, Any}"><code>PowerAnalytics.set_agg_meta!</code></a></li><li><a href="#PowerAnalytics.set_col_meta!"><code>PowerAnalytics.set_col_meta!</code></a></li><li><a href="#PowerAnalytics.unweighted_sum-Tuple{Any}"><code>PowerAnalytics.unweighted_sum</code></a></li><li><a href="#PowerAnalytics.weighted_mean-Tuple{Any, Any}"><code>PowerAnalytics.weighted_mean</code></a></li></ul><h2 id="Exported"><a class="docs-heading-anchor" href="#Exported">Exported</a><a id="Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Exported" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.AGG_META_KEY" href="#PowerAnalytics.AGG_META_KEY"><code>PowerAnalytics.AGG_META_KEY</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Column metadata key whose value, if any, is additional information to be passed to aggregation functions. Values of <code>nothing</code> are equivalent to absence of the entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L11-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.DATETIME_COL" href="#PowerAnalytics.DATETIME_COL"><code>PowerAnalytics.DATETIME_COL</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Name of the column that represents the time axis in computed DataFrames</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.META_COL_KEY" href="#PowerAnalytics.META_COL_KEY"><code>PowerAnalytics.META_COL_KEY</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Column metadata key whose value signifies whether the column is metadata. Metadata columns are excluded from <code>get_data_cols</code> and similar and can be used to represent things like a time aggregation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.RESULTS_COL" href="#PowerAnalytics.RESULTS_COL"><code>PowerAnalytics.RESULTS_COL</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Name of a column that represents whole-of-<code>Results</code> data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.SYSTEM_COL" href="#PowerAnalytics.SYSTEM_COL"><code>PowerAnalytics.SYSTEM_COL</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Name of a column that represents whole-of-<code>System</code> data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.ComponentSelectorTimedMetric" href="#PowerAnalytics.ComponentSelectorTimedMetric"><code>PowerAnalytics.ComponentSelectorTimedMetric</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Time series <code>Metrics</code> defined on <code>ComponentSelector</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.ComponentTimedMetric" href="#PowerAnalytics.ComponentTimedMetric"><code>PowerAnalytics.ComponentTimedMetric</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ComponentSelectorTimedMetrics</code> implemented by evaluating a function on each <code>Component</code>.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: the name of the <code>Metric</code></li><li><code>eval_fn</code>: a function with signature <code>(::IS.Results, ::Component; start_time::Union{Nothing, DateTime}, len::Union{Int, Nothing})</code> that returns a DataFrame representing the results for that <code>Component</code></li><li><code>component_agg_fn</code>: optional, a function to aggregate results between <code>Component</code>s/<code>ComponentSelector</code>s, defaults to <code>sum</code></li><li><code>time_agg_fn</code>: optional, a function to aggregate results across time, defaults to <code>sum</code></li><li><code>component_meta_agg_fn</code>: optional, a callable to aggregate metadata across components, defaults to <code>sum</code></li><li><code>time_meta_agg_fn</code>: optional, a callable to aggregate metadata across time, defaults to <code>sum</code></li><li><code>eval_zero</code>: optional and rarely filled in, specifies what to do in the case where there are no components to contribute to a particular group; defaults to <code>nothing</code>, in which case the data is filled in from the identity element of <code>component_agg_fn</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L15-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.CustomTimedMetric" href="#PowerAnalytics.CustomTimedMetric"><code>PowerAnalytics.CustomTimedMetric</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ComponentSelectorTimedMetrics</code> implemented without drilling down to the base <code>Component</code>s, just call the <code>eval_fn</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: the name of the <code>Metric</code></li><li><code>eval_fn</code>: a callable with signature <code>(::IS.Results, ::Union{ComponentSelector, Component}; start_time::Union{Nothing, DateTime}, len::Union{Int, Nothing})</code> that returns a DataFrame representing the results for that <code>Component</code></li><li><code>time_agg_fn</code>: optional, a callable to aggregate results across time, defaults to <code>sum</code></li><li><code>time_meta_agg_fn</code>: optional, a callable to aggregate metadata across time, defaults to <code>sum</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L47-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.Metric" href="#PowerAnalytics.Metric"><code>PowerAnalytics.Metric</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The basic type for all <code>Metrics</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.ResultsTimelessMetric" href="#PowerAnalytics.ResultsTimelessMetric"><code>PowerAnalytics.ResultsTimelessMetric</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Timeless Metrics with a single value per <code>IS.Results</code> instance</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `name::String`: the name of the `Metric`
- `eval_fn`: a callable with signature `(::IS.Results,)` that returns a `DataFrame`
  representing the results</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L86-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.SystemTimedMetric" href="#PowerAnalytics.SystemTimedMetric"><code>PowerAnalytics.SystemTimedMetric</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Time series <code>Metrics</code> defined on <code>Systems</code>.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: the name of the <code>Metric</code></li><li><code>eval_fn</code>: a callable with signature <code>(::IS.Results; start_time::Union{Nothing, DateTime}, len::Union{Int, Nothing})</code> that returns a DataFrame representing the results</li><li><code>time_agg_fn</code>: optional, a callable to aggregate results across time, defaults to <code>sum</code></li><li><code>time_meta_agg_fn</code>: optional, a callable to aggregate metadata across time, defaults to <code>sum</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L67-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.TimedMetric" href="#PowerAnalytics.TimedMetric"><code>PowerAnalytics.TimedMetric</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Time series <code>Metrics</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.TimelessMetric" href="#PowerAnalytics.TimelessMetric"><code>PowerAnalytics.TimelessMetric</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Scalar-in-time <code>Metrics</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.aggregate_time-Tuple{DataFrames.AbstractDataFrame}" href="#PowerAnalytics.aggregate_time-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.aggregate_time</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a DataFrame like that produced by <a href="#PowerAnalytics.compute_all"><code>compute_all</code></a>, group by a function of the time axis, apply a reduction, and report the resulting aggregation indexed by the first timestamp in each group.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrames.AbstractDataFrame</code>: the DataFrame to operate upon</li><li><code>groupby_fn = nothing</code>: a callable that can be passed a DateTime; two rows will be in the same group iff their timestamps produce the same result under <code>groupby_fn</code>. Note that <code>groupby_fn = month</code> puts January 2023 and January 2024 into the same group whereas <code>groupby_fn=(x -&gt; (year(x), month(x)))</code> does not.</li><li><code>groupby_col::Union{Nothing, AbstractString, Symbol} = nothing</code>: specify a column name to report the result of <code>groupby_fn</code> in the output DataFrame, or <code>nothing</code> to not</li><li><code>agg_fn = nothing</code>: by default, the aggregation function (<code>sum</code>/<code>mean</code>/etc.) is specified by the Metric, which is read from the metadata of each column. If this metadata isn&#39;t found, one can specify a default aggregation function like <code>sum</code> here; if nothing, an error will be thrown.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L166-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.categorize_data-Tuple{Dict{Symbol, DataFrames.DataFrame}, Dict}" href="#PowerAnalytics.categorize_data-Tuple{Dict{Symbol, DataFrames.DataFrame}, Dict}"><code>PowerAnalytics.categorize_data</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Re-categorizes data according to an aggregation dictionary</p><ul><li>makes no guarantee of complete data collection *</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">aggregation = PA.make_fuel_dictionary(results_uc.system)
categorize_data(gen_uc.data, aggregation)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/get_data.jl#L552-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compose_metrics" href="#PowerAnalytics.compose_metrics"><code>PowerAnalytics.compose_metrics</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Given a list of metrics and a function that applies to their results to produce one result, create a new metric that computes the sub-metrics and applies the function to produce its own result.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: the name of the new <code>Metric</code></li><li><code>reduce_fn</code>: a callable that takes one value from each of the input <code>Metric</code>s and returns a single value that will be the result of this <code>Metric</code>. &quot;Value&quot; means a vector (not a <code>DataFrame</code>) in the case of <code>TimedMetrics</code> and a scalar for <code>TimelessMetrics</code>.</li><li><code>metrics</code>: the input <code>Metrics</code>. It is currently not possible to combine <code>TimedMetrics</code> with <code>TimelessMetrics</code>, though it is possible to combine <code>ComponentSelectorTimedMetrics</code> with <code>SystemTimedMetrics</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L411-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}" href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}"><code>PowerAnalytics.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the given metric on the groups of the given <code>ComponentSelector</code> within the given set of results, returning a <code>DataFrame</code> with a <code>DateTime</code> column and a data column for each group. Exclude components marked as not available.</p><p><strong>Arguments</strong></p><ul><li><code>metric::ComponentTimedMetric</code>: the metric to compute</li><li><code>results::IS.Results</code>: the results from which to fetch data</li><li><code>selector::ComponentSelector</code>: the <code>ComponentSelector</code> on whose subselectors to compute the metric</li><li><code>start_time::Union{Nothing, DateTime} = nothing</code>: the time at which the resulting time series should begin</li><li><code>len::Union{Int, Nothing} = nothing</code>: the number of steps in the resulting time series</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L284-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, PowerSystems.Component}" href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, PowerSystems.Component}"><code>PowerAnalytics.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the given metric on the given component within the given set of results, returning a <code>DataFrame</code> with a <code>DateTime</code> column and a data column labeled with the component&#39;s name.</p><p><strong>Arguments</strong></p><ul><li><code>metric::ComponentTimedMetric</code>: the metric to compute</li><li><code>results::IS.Results</code>: the results from which to fetch data</li><li><code>comp::Component</code>: the component on which to compute the metric</li><li><code>start_time::Union{Nothing, DateTime} = nothing</code>: the time at which the resulting time series should begin</li><li><code>len::Union{Int, Nothing} = nothing</code>: the number of steps in the resulting time series</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L176-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute-Tuple{CustomTimedMetric, InfrastructureSystems.Results, Union{ComponentSelector, PowerSystems.Component}}" href="#PowerAnalytics.compute-Tuple{CustomTimedMetric, InfrastructureSystems.Results, Union{ComponentSelector, PowerSystems.Component}}"><code>PowerAnalytics.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the given metric on the given component within the given set of results, returning a <code>DataFrame</code> with a <code>DateTime</code> column and a data column labeled with the component&#39;s name. Exclude components marked as not available.</p><p><strong>Arguments</strong></p><ul><li><code>metric::CustomTimedMetric</code>: the metric to compute</li><li><code>results::IS.Results</code>: the results from which to fetch data</li><li><code>comp::Component</code>: the component on which to compute the metric</li><li><code>start_time::Union{Nothing, DateTime} = nothing</code>: the time at which the resulting time series should begin</li><li><code>len::Union{Int, Nothing} = nothing</code>: the number of steps in the resulting time series</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L191-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute-Tuple{ResultsTimelessMetric, InfrastructureSystems.Results, Nothing}" href="#PowerAnalytics.compute-Tuple{ResultsTimelessMetric, InfrastructureSystems.Results, Nothing}"><code>PowerAnalytics.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience method for <code>compute_all</code>; returns <code>compute(metric, results)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute-Tuple{ResultsTimelessMetric, InfrastructureSystems.Results}" href="#PowerAnalytics.compute-Tuple{ResultsTimelessMetric, InfrastructureSystems.Results}"><code>PowerAnalytics.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the given metric on the given set of results, returning a DataFrame with a single cell. Exclude components marked as not available.</p><p><strong>Arguments</strong></p><ul><li><code>metric::ResultsTimelessMetric</code>: the metric to compute</li><li><code>results::IS.Results</code>: the results from which to fetch data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L226-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute-Tuple{SystemTimedMetric, InfrastructureSystems.Results, Nothing}" href="#PowerAnalytics.compute-Tuple{SystemTimedMetric, InfrastructureSystems.Results, Nothing}"><code>PowerAnalytics.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience method for <code>compute_all</code>; returns <code>compute(metric, results; kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute-Tuple{SystemTimedMetric, InfrastructureSystems.Results}" href="#PowerAnalytics.compute-Tuple{SystemTimedMetric, InfrastructureSystems.Results}"><code>PowerAnalytics.compute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the given metric on the <code>System</code> associated with the given set of results, returning a <code>DataFrame</code> with a <code>DateTime</code> column and a data column.</p><p><strong>Arguments</strong></p><ul><li><code>metric::SystemTimedMetric</code>: the metric to compute</li><li><code>results::IS.Results</code>: the results from which to fetch data</li><li><code>start_time::Union{Nothing, DateTime} = nothing</code>: the time at which the resulting time series should begin</li><li><code>len::Union{Int, Nothing} = nothing</code>: the number of steps in the resulting time series</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L209-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute_all" href="#PowerAnalytics.compute_all"><code>PowerAnalytics.compute_all</code></a> — <span class="docstring-category">Function</span></header><section><div><p>For each <code>(metric, selector, col_name)</code> tuple in <code>zip(metrics, selectors, col_names)</code>, call <a href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}"><code>compute</code></a> and collect the results in a <code>DataFrame</code> with a single <code>DateTime</code> column. All selectors must yield exactly one group.</p><p><strong>Arguments</strong></p><ul><li><code>results::IS.Results</code>: the results from which to fetch data</li><li><code>metrics::Vector{&lt;:TimedMetric}</code>: the metrics to compute</li><li><code>selectors</code>: either a scalar or vector of <code>Nothing</code>/<code>Component</code>/<code>ComponentSelector</code>: the selectors on which to compute the metrics, or nothing for system/results metrics; broadcast if scalar</li><li><code>col_names::Union{Nothing, Vector{&lt;:Union{Nothing, AbstractString}}} = nothing</code>: a vector of names for the columns of ouput data. Entries of <code>nothing</code> default to the result of <a href="#PowerAnalytics.metric_selector_to_string-Tuple{Metric, Union{ComponentSelector, PowerSystems.Component}}"><code>metric_selector_to_string</code></a>; <code>names = nothing</code> is equivalent to an entire vector of <code>nothing</code></li><li><code>kwargs...</code>: pass through to each <a href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}"><code>compute</code></a> call</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L337-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute_all" href="#PowerAnalytics.compute_all"><code>PowerAnalytics.compute_all</code></a> — <span class="docstring-category">Function</span></header><section><div><p>For each (metric, col<em>name) tuple in `zip(metrics, col</em>names)<code>, call [</code>compute`](@ref) and collect the results in a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>results::IS.Results</code>: the results from which to fetch data</li><li><code>metrics::Vector{&lt;:TimelessMetric}</code>: the metrics to compute</li><li><code>selectors</code>: either a scalar or vector of <code>Nothing</code>/<code>Component</code>/<code>ComponentSelector</code>: the selectors on which to compute the metrics, or nothing for system/results metrics; broadcast if scalar</li><li><code>col_names::Union{Nothing, Vector{&lt;:Union{Nothing, AbstractString}}} = nothing</code>: a vector of names for the columns of ouput data. Entries of <code>nothing</code> default to the result of <a href="#PowerAnalytics.metric_selector_to_string-Tuple{Metric, Union{ComponentSelector, PowerSystems.Component}}"><code>metric_selector_to_string</code></a>; <code>names = nothing</code> is equivalent to an entire vector of <code>nothing</code><ul><li><code>kwargs...</code>: pass through to each <a href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}"><code>compute</code></a> call</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L361-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.compute_all-Tuple{InfrastructureSystems.Results, Vararg{Tuple{Union{TimedMetric, TimelessMetric}, Any, Any}}}" href="#PowerAnalytics.compute_all-Tuple{InfrastructureSystems.Results, Vararg{Tuple{Union{TimedMetric, TimelessMetric}, Any, Any}}}"><code>PowerAnalytics.compute_all</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For each (metric, selector, col_name) tuple in <code>computations</code>, call <a href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}"><code>compute</code></a> and collect the results in a DataFrame with a single <code>DateTime</code> column. All selectors must yield exactly one group.</p><p><strong>Arguments</strong></p><ul><li><code>results::IS.Results</code>: the results from which to fetch data</li><li><code>computations::(Tuple{&lt;:T, Any, Any} where T &lt;: Union{TimedMetric, TimelessMetric})...</code>: a list of the computations to perform, where each element is a <code>(metric, selector, col_name)</code><code>where</code>metric<code>is the metric to compute,</code>selector<code>is the ComponentSelector on which to compute the metric or</code>nothing<code>if not relevant, and</code>col_name` is the name for the output column of data or nothing to use the default<ul><li><code>kwargs...</code>: pass through to each <a href="#PowerAnalytics.compute-Tuple{ComponentTimedMetric, InfrastructureSystems.Results, ComponentSelector}"><code>compute</code></a> call</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L385-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.create_problem_results_dict" href="#PowerAnalytics.create_problem_results_dict"><code>PowerAnalytics.create_problem_results_dict</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Accept a directory that contains several results subdirectories (that each contain <code>results</code>, <code>problems</code>, etc. sub-subdirectories) and construct a sorted dictionary from <code>String</code> to <code>SimulationProblemResults</code> where the keys are the subdirectory names and the values are loaded results datasets.</p><p><strong>Arguments</strong></p><ul><li><code>results_dir::AbstractString</code>: the directory where results subdirectories can be found</li><li><code>problem::String</code>: the name of the problem to load (e.g., &quot;UC&quot;, &quot;ED&quot;)</li><li><code>scenarios::Union{Vector{AbstractString}, Nothing} = nothing</code>: a list of scenario subdirectories to load, or <code>nothing</code> to load all the subdirectories</li><li><code>kwargs...</code>: keyword arguments to pass through to <a href="api/@ref"><code>PSI.get_decision_problem_results</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_agg_meta-Tuple{Any, Any}" href="#PowerAnalytics.get_agg_meta-Tuple{Any, Any}"><code>PowerAnalytics.get_agg_meta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the column&#39;s aggregation metadata; return <code>nothing</code> if there is none.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_agg_meta-Tuple{Any}" href="#PowerAnalytics.get_agg_meta-Tuple{Any}"><code>PowerAnalytics.get_agg_meta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the single data column&#39;s aggregation metadata; error on multiple data columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_data_cols-Tuple{DataFrames.AbstractDataFrame}" href="#PowerAnalytics.get_data_cols-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_data_cols</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Select the names of the data columns of the <code>DataFrame</code>, i.e., those that are not <code>DateTime</code> and not metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L61-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_data_df-Tuple{DataFrames.AbstractDataFrame}" href="#PowerAnalytics.get_data_df-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_data_df</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Select the data columns of the <code>DataFrame</code> as a <code>DataFrame</code> without copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_data_mat-Tuple{DataFrames.AbstractDataFrame}" href="#PowerAnalytics.get_data_mat-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_data_mat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Select the data columns of the <code>DataFrame</code> as a <code>Matrix</code> with copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_data_vec-Tuple{DataFrames.AbstractDataFrame}" href="#PowerAnalytics.get_data_vec-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_data_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Select the data column of the <code>DataFrame</code> as a vector without copying, errors if more than one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_time_df-Tuple{DataFrames.AbstractDataFrame}" href="#PowerAnalytics.get_time_df-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_time_df</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Select the <code>DateTime</code> column of the <code>DataFrame</code> as a one-column <code>DataFrame</code> without copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_time_vec-Tuple{DataFrames.AbstractDataFrame}" href="#PowerAnalytics.get_time_vec-Tuple{DataFrames.AbstractDataFrame}"><code>PowerAnalytics.get_time_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Select the <code>DateTime</code> column of the <code>DataFrame</code> as a <code>Vector</code> without copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.hcat_timed_dfs-Tuple{Vararg{DataFrames.DataFrame}}" href="#PowerAnalytics.hcat_timed_dfs-Tuple{Vararg{DataFrames.DataFrame}}"><code>PowerAnalytics.hcat_timed_dfs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If the time axes match across all the <code>DataFrames</code>, horizontally concatenate them and remove the duplicate time axes. If not, throw an error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L118-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.is_col_meta-Tuple{Any, Any}" href="#PowerAnalytics.is_col_meta-Tuple{Any, Any}"><code>PowerAnalytics.is_col_meta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check whether a column is metadata</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.make_fuel_dictionary-Tuple{PowerSystems.System, Dict{NamedTuple, String}}" href="#PowerAnalytics.make_fuel_dictionary-Tuple{PowerSystems.System, Dict{NamedTuple, String}}"><code>PowerAnalytics.make_fuel_dictionary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generators = make_fuel_dictionary(system::PSY.System, mapping::Dict{NamedTuple, String})</code></pre><p>This function makes a dictionary of fuel type and the generators associated.</p><p><strong>Arguments</strong></p><ul><li><code>sys::PSY.System</code>: the system that is used to create the results</li><li><code>results::IS.Results</code>: results</li></ul><p><strong>Key Words</strong></p><ul><li><code>categories::Dict{String, NamedTuple}</code>: if stacking by a different category is desired</li></ul><p><strong>Example</strong></p><p>results = solve<em>op</em>model!(OpModel) generators = make<em>fuel</em>dictionary(sys)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/fuel_results.jl#L67-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.metric_selector_to_string-Tuple{Metric, Union{ComponentSelector, PowerSystems.Component}}" href="#PowerAnalytics.metric_selector_to_string-Tuple{Metric, Union{ComponentSelector, PowerSystems.Component}}"><code>PowerAnalytics.metric_selector_to_string</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Canonical way to represent a <code>(Metric, ComponentSelector)</code> or <code>(Metric, Component)</code> pair as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L134-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.parse_generator_categories-Tuple{Any}" href="#PowerAnalytics.parse_generator_categories-Tuple{Any}"><code>PowerAnalytics.parse_generator_categories</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Use <a href="#PowerAnalytics.parse_generator_mapping_file-Tuple{Any}"><code>parse_generator_mapping_file</code></a> to parse a <code>generator_mapping.yaml</code> file into a dictionary of <code>ComponentSelector</code>, excluding categories in the &#39;non_generators&#39; list in metadata</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/builtin_component_selectors.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.parse_generator_mapping_file-Tuple{Any}" href="#PowerAnalytics.parse_generator_mapping_file-Tuple{Any}"><code>PowerAnalytics.parse_generator_mapping_file</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse a <code>generator_mapping.yaml</code> file into a dictionary of <code>ComponentSelector</code>s and a dictionary of metadata if present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/builtin_component_selectors.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.parse_injector_categories-Tuple{Any}" href="#PowerAnalytics.parse_injector_categories-Tuple{Any}"><code>PowerAnalytics.parse_injector_categories</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Use <a href="#PowerAnalytics.parse_generator_mapping_file-Tuple{Any}"><code>parse_generator_mapping_file</code></a> to parse a <code>generator_mapping.yaml</code> file into a dictionary of all <code>ComponentSelector</code>s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/builtin_component_selectors.jl#L103-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.rebuild_metric-Tuple{T} where T&lt;:Metric" href="#PowerAnalytics.rebuild_metric-Tuple{T} where T&lt;:Metric"><code>PowerAnalytics.rebuild_metric</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a <code>Metric</code> identical to the input <code>metric</code> except with the changes to its fields specified in the keyword arguments.</p><p><strong>Examples</strong></p><p>Make a variant of <code>calc_active_power</code> that averages across components rather than summing:</p><pre><code class="language-julia hljs">using PowerAnalytics.Metrics
calc_active_power_mean = rebuild_metric(calc_active_power; component_agg_fn = mean)
# (now calc_active_power_mean works as a standalone, callable metric)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L116-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.set_agg_meta!-Tuple{Any, Any, Any}" href="#PowerAnalytics.set_agg_meta!-Tuple{Any, Any, Any}"><code>PowerAnalytics.set_agg_meta!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the column&#39;s aggregation metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.set_agg_meta!-Tuple{Any, Any}" href="#PowerAnalytics.set_agg_meta!-Tuple{Any, Any}"><code>PowerAnalytics.set_agg_meta!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Set the single data column&#39;s aggregation metadata; error on multiple data columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.set_col_meta!" href="#PowerAnalytics.set_col_meta!"><code>PowerAnalytics.set_col_meta!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Mark a column as metadata</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/output_utils.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.unweighted_sum-Tuple{Any}" href="#PowerAnalytics.unweighted_sum-Tuple{Any}"><code>PowerAnalytics.unweighted_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A version of <code>sum</code> that ignores a second argument, for use where aggregation metadata is at play</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/builtin_metrics.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.weighted_mean-Tuple{Any, Any}" href="#PowerAnalytics.weighted_mean-Tuple{Any, Any}"><code>PowerAnalytics.weighted_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the mean of <code>values</code> weighted by the corresponding entries of <code>weights</code>. Arguments may be vectors or vectors of vectors. A weight of 0 cancels out a value of NaN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/builtin_metrics.jl#L19-L22">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.EntryType" href="#PowerAnalytics.EntryType"><code>PowerAnalytics.EntryType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The various key entry types that can be used to make a PSI.OptimizationContainerKey</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.SystemEntryType" href="#PowerAnalytics.SystemEntryType"><code>PowerAnalytics.SystemEntryType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The various key entry types that can work with a System</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.NoResultError" href="#PowerAnalytics.NoResultError"><code>PowerAnalytics.NoResultError</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The metric does not have a result for the <code>Component</code>/<code>ComponentSelector</code>/etc. on which it is being called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/metrics.jl#L99-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.combine_categories-Tuple{Union{Dict{String, DataFrames.DataFrame}, Dict{Symbol, DataFrames.DataFrame}}}" href="#PowerAnalytics.combine_categories-Tuple{Union{Dict{String, DataFrames.DataFrame}, Dict{Symbol, DataFrames.DataFrame}}}"><code>PowerAnalytics.combine_categories</code></a> — <span class="docstring-category">Method</span></header><section><div><p>aggregates and combines data into single DataFrame</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">PG.combine_categories(gen_uc.data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/get_data.jl#L521-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_generator_category-Tuple{Any, Any, Any, Any, Dict{NamedTuple, String}}" href="#PowerAnalytics.get_generator_category-Tuple{Any, Any, Any, Any, Dict{NamedTuple, String}}"><code>PowerAnalytics.get_generator_category</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the generator category for this fuel and unit_type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/fuel_results.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.get_generator_mapping" href="#PowerAnalytics.get_generator_mapping"><code>PowerAnalytics.get_generator_mapping</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a dict where keys are a tuple of input parameters (fuel, unit_type) and values are generator types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/fuel_results.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.lookup_gentype-Tuple{AbstractString}" href="#PowerAnalytics.lookup_gentype-Tuple{AbstractString}"><code>PowerAnalytics.lookup_gentype</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse the <code>gentype</code> to a type. This is done by first checking whether gentype is qualified (<code>ModuleName.TypeName</code>). If so, the module is fetched from the <code>Main</code> scope and the type name is fetched from the module. If not, we default to fetching from <code>PowerSystems</code> for convenience.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/builtin_component_selectors.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.make_component_metric_from_entry-Tuple{String, Type{&lt;:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}}" href="#PowerAnalytics.make_component_metric_from_entry-Tuple{String, Type{&lt;:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}}"><code>PowerAnalytics.make_component_metric_from_entry</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience function to convert an EntryType to a function and make a ComponentTimedMetric from it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/builtin_metrics.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.make_entry_kwargs-Tuple{Vector{&lt;:Tuple}}" href="#PowerAnalytics.make_entry_kwargs-Tuple{Vector{&lt;:Tuple}}"><code>PowerAnalytics.make_entry_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sort a vector of key tuples into variables, parameters, etc. like PSI.load_results! wants</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.make_key" href="#PowerAnalytics.make_key"><code>PowerAnalytics.make_key</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a PSI.OptimizationContainerKey from the given key entry type and component.</p><p><strong>Arguments</strong></p><ul><li><code>entry::Type{&lt;:EntryType}</code>: the key entry</li><li><code>component</code> (<code>::Type{&lt;:Union{Component, PSY.System}}</code> or <code>::Type{&lt;:Component}</code> depending on the key type): the component type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.make_system_metric_from_entry-Tuple{String, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}}" href="#PowerAnalytics.make_system_metric_from_entry-Tuple{String, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}}"><code>PowerAnalytics.make_system_metric_from_entry</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience function to convert a SystemEntryType to a function and make a SystemTimedMetric from it</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/builtin_metrics.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.read_component_result-Tuple{InfrastructureSystems.Results, Type{&lt;:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}, PowerSystems.Component}" href="#PowerAnalytics.read_component_result-Tuple{InfrastructureSystems.Results, Type{&lt;:Union{InfrastructureSystems.Optimization.AuxVariableType, InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.InitialConditionType, InfrastructureSystems.Optimization.ParameterType, InfrastructureSystems.Optimization.VariableType}}, PowerSystems.Component}"><code>PowerAnalytics.read_component_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given an EntryType and a Component, fetch a single column of results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerAnalytics.read_system_result-Tuple{InfrastructureSystems.Results, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}}" href="#PowerAnalytics.read_system_result-Tuple{InfrastructureSystems.Results, Type{&lt;:Union{InfrastructureSystems.Optimization.ExpressionType, InfrastructureSystems.Optimization.VariableType}}}"><code>PowerAnalytics.read_system_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given an EntryType that applies to the System, fetch a single column of results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerAnalytics.jl/blob/fff5404e72222a62e95a7f0e9ea69581d9bda3e6/src/input_utils.jl#L159">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 6 February 2025 19:27">Thursday 6 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
